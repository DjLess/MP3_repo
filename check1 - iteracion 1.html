<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DJ App Mockup con Indicador de Kicks Sincronizados</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            background-color: #1a202c; /* Fondo oscuro para el body */
            color: #e2e8f0; /* Color de texto claro */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ocupa al menos el 100% de la altura de la ventana */
        }
        /* Estilos base del frame del teléfono */
        .phone-frame {
            width: 375px;
            height: 700px;
            background-color: #1a202c;
            border-radius: 40px;
            box-shadow: 0 0 0 8px #2d3748,
                                 0 0 0 12px #1a202c,
                                 0 20px 50px rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
            flex-direction: column;
            padding-bottom: 50px;
        }

        .notch {
            width: 120px;
            height: 25px;
            background-color: #1a202c;
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
        }

        /* Estilos de la onda de audio (simulada) */
        .waveform {
            height: 40px;
            background: repeating-linear-gradient(90deg,
                #2d3748 0%, #2d3748 5%,
                #4a5568 5%, #4a5568 10%,
                #2d3748 10%, #2d3748 15%,
                #4a5568 15%, #4a5568 20%,
                #2d3748 20%, #2d3748 25%,
                #4a5568 25%, #4a5568 30%,
                #2d3748 30%, #2d3748 35%,
                #4a5568 35%, #4a5568 40%,
                #2d3748 40%, #2d3748 45%,
                #4a5568 45%, #4a5568 50%
            );
            background-size: 200px 100%;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            flex-grow: 1;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
        }

        .waveform.red {
            background: repeating-linear-gradient(90deg,
                #374151 0%, #374151 5%,
                #4b5563 5%, #4b5563 10%,
                #374151 10%, #374151 15%,
                #4b5563 15%, #4b5563 20%,
                #374151 20%, #374151 25%,
                #4b5563 25%, #4b5563 30%,
                #374151 30%, #374151 35%,
                #4b5563 35%, #4b5563 40%,
                #374151 40%, #374151 45%,
                #4b5563 45%, #4b5563 50%
            );
            background-size: 200px 100%;
        }

        .waveform-progress {
            height: 100%;
            background-color: rgba(66, 153, 225, 0.7);
            position: absolute;
            left: 0;
            top: 0;
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 8px;
        }

        /* Estilos del jog wheel */
        .jog-wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 4px solid #4a5568;
            background-color: #2d3748;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.6);
            /* Removed transition here, handled by JS requestAnimationFrame for smoothness */
            z-index: 10;
        }

        .jog-wheel:active {
            cursor: grabbing;
        }

        /* NEW: Styles for the SVG trace */
        .jog-trace-svg {
            position: absolute; /* Position it relative to jog-wheel */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg); /* Rotate SVG to start trace at top */
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.7)); /* Glow effect */
        }

        /* Removed old .jog-indicator and @keyframes throb */

        /* Estilos del contenedor del visualizador de kick */
        .kick-visualizer-container {
            width: 100px;
            height: 40px;
            border-radius: 10px;
            background-color: #374151;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .kick-pulse-element {
            width: 40px;
            height: 40px;
            background-color: #4299e1;
            border-radius: 5px;
            opacity: 0;
            transform: scale(0.5);
            transition: opacity 0.05s ease-out, transform 0.05s ease-out;
        }

        .kick-pulse-element.active {
            transform: scale(1.1);
            opacity: 1;
        }

        /* Indicador de kicks sincronizados */
        #synced-kicks-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(74, 222, 128, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 30;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #synced-kicks-indicator.active {
            opacity: 1;
        }

        /* Estilo para el botón de debug */
        #debug-play-all {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #6b7280;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            z-index: 50;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease-in-out;
        }

        #debug-play-all:hover {
            background-color: #4a5568;
        }

        /* Estilo para los sliders verticales (BPM faders) */
        .vertical-fader {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 12px;
            background: #4a5568;
            outline: none;
            border-radius: 6px;
            z-index: 1;
            transform: rotate(-90deg);
            transform-origin: center;
            margin: 0;
        }

        .vertical-fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 20px;
            background: #63b3ed;
            border-radius: 4px;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .vertical-fader::-moz-range-thumb {
            width: 30px;
            height: 20px;
            background: #63b3ed;
            border-radius: 4px;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Adjusted styles for elements that were in fader-group-abs, now individual */
       .bpm-label-abs { /* New class for the BPM text element */
            font-size: 0.875rem; /* text-sm */
            font-weight: 600;
            color: #90cdf4;
            /* margin-bottom: 4px; */ /* Removed as individual positioning */
        }

        .bpm-value {
            font-size: 1.125rem; /* text-lg */
            /* margin-bottom: 8px; */ /* Removed as individual positioning */
        }

        .play-button, .cue-button {
            padding: 8px 12px;
            font-size: 0.875rem;
            border-radius: 9999px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease-in-out;
            width: 90px;
            text-align: center;
        }
        .play-button {
            background-color: #63b3ed;
            color: white;
        }
        .play-button:hover {
            background-color: #4299e1;
        }

        .cue-button {
            background-color: #f6ad55;
            color: white;
        }
        .cue-button:hover {
            background-color: #ed8936;
        }

        /* Styles for Crossfader */
        .crossfader-container {
            width: 100%;
            padding: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .crossfader-container input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            max-width: 250px;
            height: 10px;
            background: #4a5568;
            outline: none;
            border-radius: 5px;
        }

        .crossfader-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #63b3ed;
            border-radius: 50%;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .crossfader-container input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #63b3ed;
            border-radius: 50%;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* NUEVOS ESTILOS PARA LA VISUALIZACIÓN DE BEATS */
        .beat-visualization-container {
            width: 300px;
            height: 50px;
            background-color: #2d3748;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            padding: 0;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            z-index: 5;
            justify-content: center;
            transition: box-shadow 0.1s ease-out; /* Add transition for smooth glow */
        }

        .beat-visualization-container.glow-left {
            box-shadow: 0 0 25px 5px rgba(229, 62, 62, var(--glow-intensity-left, 0)); /* Blue glow for left */
        }

        .beat-visualization-container.glow-right {
            box-shadow: 0 0 25px 5px rgba(66, 153, 225, var(--glow-intensity-right, 0)); /* Red glow for right */
        }

        .beat-bars-wrapper {
            display: flex;
            height: 100%;
            align-items: center;
            will-change: transform;
        }

        .beat-bar {
            border-radius: 3px;
            opacity: 0.5;
            transition: background-color 0.1s ease-out, opacity 0.1s ease-out, transform 0.1s ease-out, height 0.1s ease-out;
            flex-shrink: 0;
            margin: 0 1px;
        }

        .beat-bar.beat-type-kick {
            background-color: #4299e1;
            height: 35px;
            transform: scale(1.0);
        }

        .beat-bar.beat-type-2,
        .beat-bar.beat-type-3,
        .beat-bar.beat-type-4 {
            background-color: #a0aec0;
            height: 25px;
            transform: scale(0.7);
        }

        .beat-bar.active-beat {
            background-color: #e53e3e;
            opacity: 1;
            transform: scale(1.3);
            height: 40px;
        }

        .beat-bar.next-beat {
            background-color: #f6e05e;
            opacity: 0.9;
            transform: scale(1.1);
            height: 30px;
        }

        .line-indicator {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            height: 100%;
            width: 2px;
            background-color: #e53e3e;
            z-index: 10;
            box-shadow: 0 0 5px rgba(229, 62, 62, 0.7);
        }

        /* Styles for zoom buttons */
        .zoom-buttons {
            display: flex;
            gap: 5px;
        }

        .zoom-button {
            background-color: #4a5568;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }

        .zoom-button:hover {
            background-color: #2d3748;
        }
    </style>

</head>
<body>
    <div class="phone-frame">
        <div class="notch"></div>

        <div class="bg-gray-900 text-gray-100 font-inter flex flex-col items-center justify-start w-full h-full">
            <div class="relative w-full p-4 flex items-center justify-between z-10">
                <button class="text-gray-400 hover:text-white text-2xl font-bold">X</button>
                <div class="h-4 bg-green-500 rounded-full w-3/4 mx-auto"></div>
            </div>




        </div>

        <div id="synced-kicks-indicator" class="absolute" style="top: 100px; left: 50%; transform: translateX(-50%);">¡Kicks Sincronizados!</div>

        <div id="jog-wheel-1" class="jog-wheel absolute" style="top: 350px; left: -70px;">
            <svg class="jog-trace-svg" viewBox="0 0 200 200">
                <defs>
                    <linearGradient id="gradientTrace" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(255,255,255,0.0)" />
                        <stop offset="30%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="70%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="100%" style="stop-color:rgba(255,255,255,0.0)" />
                    </linearGradient>
                </defs>
                <circle id="jog-trace-circle-1" cx="100" cy="100" r="90" fill="none" stroke="url(#gradientTrace)" stroke-width="10" stroke-linecap="round"></circle>
            </svg>
        </div>
        <div id="jog-wheel-2" class="jog-wheel absolute" style="top: 350px; right: -70px;">
            <svg class="jog-trace-svg" viewBox="0 0 200 200">
                <defs>
                    <linearGradient id="gradientTrace" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(255,255,255,0.0)" />
                        <stop offset="30%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="70%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="100%" style="stop-color:rgba(255,255,255,0.0)" />
                    </linearGradient>
                </defs>
                <circle id="jog-trace-circle-2" cx="100" cy="100" r="90" fill="none" stroke="url(#gradientTrace)" stroke-width="10" stroke-linecap="round"></circle>
            </svg>
        </div>

        <div id="beat-visualizer-1" class="beat-visualization-container absolute" style="top: 180px; left: 35px;">
            <div class="line-indicator"></div>
            <div id="beat-bars-wrapper-1" class="beat-bars-wrapper"></div>
            <div class="absolute left-0 top-1/2 -translate-y-1/2 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-r-md z-20">C1</div>
        </div>
        <div class="zoom-buttons absolute" style="top: 130px; left: 35px;">
            <button id="zoom-out-1" class="zoom-button">-</button>
            <button id="zoom-in-1" class="zoom-button">+</button>
        </div>
       
        <h2 class="text-sm font-semibold text-blue-300 bpm-label-abs absolute" style="top: 80px; left: 45px;">BPM: <span id="bpm-value-1" class="bpm-value">145.0</span></h2>
        <button id="sync-1" class="bg-purple-600 hover:bg-purple-700 text-white text-xs font-bold py-1 px-2 rounded-md shadow-lg transition-all duration-200 absolute" style="top: 480px; left: 55px;">
            SYNC
        </button>
        <input type="range" id="bpm-slider-1" class="vertical-fader absolute" style="top: 440px; left: 80px; transform: rotate(-90deg);">


        <div id="beat-visualizer-2" class="beat-visualization-container absolute" style="top: 250px; left: 35px;">
            <div class="line-indicator"></div>
            <div id="beat-bars-wrapper-2" class="beat-bars-wrapper"></div>
            <div class="absolute right-0 top-1/2 -translate-y-1/2 bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded-l-md z-20">C2</div>
        </div>
        <div class="zoom-buttons absolute" style="top: 130px; right: 35px;">
            <button id="zoom-out-2" class="zoom-button">-</button>
            <button id="zoom-in-2" class="zoom-button">+</button>
        </div>

        <h2 class="text-sm font-semibold text-blue-300 bpm-label-abs absolute" style="top: 80px; right: 45px;">BPM: <span id="bpm-value-2" class="bpm-value">130.0</span></h2>
        <button id="sync-2" class="bg-purple-600 hover:bg-purple-700 text-white text-xs font-bold py-1 px-2 rounded-md shadow-lg transition-all duration-200 absolute" style="top: 480px; right: 55px;">
            SYNC
        </button>
        <input type="range" id="bpm-slider-2" class="vertical-fader absolute" style="top: 440px; right: 80px; transform: rotate(-90deg);">


        <div class="play-cue-buttons-abs absolute" style="bottom: 95px; left: 50%; transform: translateX(-50%); display: flex; gap: 180px;">
            <button id="cue-1" class="cue-button">CUE L</button>
            <button id="cue-2" class="cue-button">CUE R</button>
        </div>

        <div class="play-cue-buttons-abs absolute" style="bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 180px;">
            <button id="play-pause-1" class="play-button">▶️ PLAY A</button>
            <button id="play-pause-2" class="play-button">▶️ PLAY B</button>
        </div>

        <div class="crossfader-container absolute" style="bottom: 60px; left: 0; right: 0; width: 100%; max-width: 180px; margin: 0 auto;">
            <label for="crossfader" class="sr-only">Crossfader</label>
            <input type="range" id="crossfader" min="0" max="1" value="0.5" step="0.01">
        </div>

        <button id="debug-play-all" class="absolute" style="bottom: 0px; left: 50%; transform: translateX(-50%);">
            ▶️▶️ Play All
        </button>

    </div>

    <audio id="audio1" src="https://raw.githubusercontent.com/DjLess/MP3_repo/main/SCREECHMASTER.mp3" preload="auto"></audio>
    <audio id="audio2" src="https://raw.githubusercontent.com/DjLess/MP3_repo/main/Somewhere%20Over%20The%20Rainbow%20-%20Polizzi%20Vs%20Richter%20(%20Israel%20IZ%20Techno%20Bootleg).mp3" preload="auto"></audio>

    <script>
        // Get references to audio elements
        const audio1 = document.getElementById('audio1');
        const audio2 = document.getElementById('audio2');

        // Get references to play/pause buttons
        const playPause1 = document.getElementById('play-pause-1');
        const playPause2 = document.getElementById('play-pause-2');

        // Get references to CUE buttons
        const cue1Button = document.getElementById('cue-1');
        const cue2Button = document.getElementById('cue-2');

        // Get references to the "Play All" debug button
        const debugPlayAllButton = document.getElementById('debug-play-all');

        // Get references to BPM sliders and their values
        const bpmSlider1 = document.getElementById('bpm-slider-1');
        const bpmValue1 = document.getElementById('bpm-value-1');
        const bpmSlider2 = document.getElementById('bpm-slider-2');
        const bpmValue2 = document.getElementById('bpm-value-2');

        // Get references to SYNC buttons
        const sync1 = document.getElementById('sync-1');
        const sync2 = document.getElementById('sync-2');

        // Get references to jog wheels
        const jogWheel1 = document.getElementById('jog-wheel-1');
        const jogWheel2 = document.getElementById('jog-wheel-2');

        // Get references to the beat visualizer containers and their inner wrappers
        const beatVisualizer1 = document.getElementById('beat-visualizer-1');
        const beatVisualizer2 = document.getElementById('beat-visualizer-2');
        const beatBarsWrapper1 = document.getElementById('beat-bars-wrapper-1');
        const beatBarsWrapper2 = document.getElementById('beat-bars-wrapper-2');

        // Remapping for the old kick pulse logic (targeting the main visualizer div for the 'active' class)
        // IMPORTANT: These must be defined AFTER beatVisualizer1/2
        const kickPulse1 = beatVisualizer1;
        const kickPulse2 = beatVisualizer2;

        // Get reference to the synced kicks indicator
        const syncedKicksIndicator = document.getElementById('synced-kicks-indicator');


        // Get reference to the crossfader
        const crossfader = document.getElementById('crossfader');

        // NEW REFERENCES FOR ZOOM BUTTONS
        const zoomIn1 = document.getElementById('zoom-in-1');
        const zoomOut1 = document.getElementById('zoom-out-1');
        const zoomIn2 = document.getElementById('zoom-in-2');
        const zoomOut2 = document.getElementById('zoom-out-2');

        // Get references to the new SVG circle elements for the trace
        const jogTraceCircle1 = document.getElementById('jog-trace-circle-1');
        const jogTraceCircle2 = document.getElementById('jog-trace-circle-2');


        // Variables to store kick intervals
        let kickInterval1 = null;
        let kickInterval2 = null;

        // Variables to store CUE points
        let cuePoint1 = 0; // Default to start of track
        let cuePoint2 = 0; // Default to start of track

        // Variables for beat visualization timeouts (for highlighting)
        let beatHighlightTimeouts1 = [];
        let beatHighlightTimeouts2 = [];

        // Variables for continuous animation control
        let animationFrameId1 = null; // for beat visualizer
        let animationFrameId2 = null; // for beat visualizer

        // Beat visualization configuration
        const SUB_BEATS_PER_MAIN_BEAT = 4; // Each main beat is divided into 4 sub-beats (e.g., 16th notes)

        // Zoom levels for beat visualization (number of main beats displayed)
        const ZOOM_LEVELS = [4, 8, 16, 32];
        let currentNumMainBeatsDisplayed1 = 8; // Initial display for track 1
        let currentNumMainMainBeatsDisplayed2 = 8; // Initial display for track 2

        // Constant for the total number of sub-beats to generate for continuous scrolling
        const TOTAL_GENERATED_SUB_BEATS = 64 * SUB_BEATS_PER_MAIN_BEAT; // Generate enough for 64 main beats (256 sub-beats)

        // Define minimum visual properties for bars and gaps
        const MIN_BAR_WIDTH_VISUAL = 1;
        const MIN_GAP_VISUAL = 0.5;

        // Reference BPM for visual density scaling
        const REFERENCE_BPM_FOR_VISUAL_DENSITY = 120; // Example reference BPM

        // Window of time in milliseconds during which a kick is considered "active"
        const KICK_ACTIVE_WINDOW_MS = 400;
        const BPM_TOLERANCE = 0.5;
        const VISUALIZATION_DURATION_MS = 200; // Duration in milliseconds that the visual kick pulse is active

        // Initial base BPMs for each track
        let initialBaseBPM1 = 145; // These will be updated by loadSong
        let initialBaseBPM2 = 130; // These will be updated by loadSong

        // Define the BPM range for sliders (+- 16 BPM)
        const BPM_RANGE = 16;

        /**
         * Sets up the min/max range and initial value for a BPM slider.
         * @param {HTMLInputElement} slider - The BPM slider element.
         * @param {number} initialBPM - The initial BPM for the track.
         */
        function setupBPMSlider(slider, initialBPM) {
            // Invert min/max so that the highest value is visually at the top
            slider.min = (initialBPM - BPM_RANGE).toFixed(1);
            slider.max = (initialBPM + BPM_RANGE).toFixed(1);
            slider.value = initialBPM.toFixed(1); // Initial value is the base BPM
            slider.step = 0.1;
        }

        // Initialize BPM sliders with correct range
        setupBPMSlider(bpmSlider1, initialBaseBPM1);
        setupBPMSlider(bpmSlider2, initialBaseBPM2);

        /**
         * Activates the visual kick pulse for a specific duration.
         * @param {HTMLElement} element - The visual pulse element.
         */
        function activarVisualizacionKick(element) {
            element.classList.add('active');
            setTimeout(() => {
                element.classList.remove('active');
            }, VISUALIZATION_DURATION_MS);
        }

        /**
         * Starts the kick animation based on an interval.
         * @param {HTMLAudioElement} audio - The audio element.
         * @param {HTMLElement} pulseElement - The visual pulse element.
         * @param {string} intervalVariableName - Name of the global variable holding the interval ID (e.g., 'kickInterval1').
         * @param {number} bpm - Current BPM of the track.
         */
        function startKickAnimationInterval(audio, pulseElement, intervalVariableName, bpm) {
            // Clear any existing interval for this track
            if (window[intervalVariableName]) {
                clearInterval(window[intervalVariableName]);
            }

            const msPerBeat = (60 / bpm) * 1000;

            // Start the interval
            window[intervalVariableName] = setInterval(() => {
                // Only activate the kick if audio is playing
                if (!audio.paused) {
                    activarVisualizacionKick(pulseElement);
                }
            }, msPerBeat);
        }

        /**
         * Continuously checks if kicks of both tracks are sounding simultaneously
         * (based on whether the visual element is active) and if BPMs are similar.
         */
        function checkSyncedKicks() {
            // Check if both visual kick elements are active
            const isKick1VisuallyActive = kickPulse1.classList.contains('active');
            const isKick2VisuallyActive = kickPulse2.classList.contains('active');

            // Get current BPMs (values displayed on the interface)
            const currentBPM1 = parseFloat(bpmValue1.textContent);
            const currentBPM2 = parseFloat(bpmValue2.textContent);

            // Check if BPMs are similar within the defined tolerance
            const areBPMsSimilar = Math.abs(currentBPM1 - currentBPM2) <= BPM_TOLERANCE;

            // Activate/deactivate sync indicator
            // Only activates if both kicks are visually active, BPMs are similar,
            // and both audios are playing.
            if (isKick1VisuallyActive && isKick2VisuallyActive && areBPMsSimilar && !audio1.paused && !audio2.paused) {
                syncedKicksIndicator.classList.add('active');
            } else {
                syncedKicksIndicator.classList.remove('active');
            }

            // Recursively call for a continuous loop in the next animation frame
            requestAnimationFrame(checkSyncedKicks);
        }

        /**
         * Clears all pending timeouts for beat highlighting for a given track.
         * @param {Array<number>} timeoutsArray - The array of timeout IDs.
         */
        function clearBeatHighlightTimeouts(timeoutsArray) {
            timeoutsArray.forEach(timeoutId => clearTimeout(timeoutId));
            timeoutsArray.length = 0; // Clear the array
        }

        /**
         * Generates and appends beat bars to the specified wrapper.
         * @param {HTMLElement} wrapper - The beat bars wrapper element.
         * @param {number} numMainBeats - The number of main beats to generate.
         * @param {number} subBeatsPerMainBeat - The number of sub-beats per main beat.
         * @param {number} wrapperWidth - The width of the beat visualizer container.
         */
        function generateBeatBars(wrapper, numMainBeats, subBeatsPerMainBeat, wrapperWidth) {
            wrapper.innerHTML = ''; // Clear existing bars
            const totalSubBeats = TOTAL_GENERATED_SUB_BEATS; // Generate a fixed large number of bars

            // Calculate optimal bar width and gap based on the wrapper width and number of beats to display
            const effectiveWidth = wrapperWidth - (MIN_GAP_VISUAL * (totalSubBeats - 1));
            let barWidth = Math.max(MIN_BAR_WIDTH_VISUAL, effectiveWidth / totalSubBeats);
            let gap = MIN_GAP_VISUAL;

            // Adjust barWidth if it becomes too large, potentially reducing gap if needed, or capping barWidth
            if (barWidth > (wrapperWidth / (totalSubBeats / 2))) { // Heuristic to prevent excessively wide bars
                barWidth = (wrapperWidth / (totalSubBeats / 2));
                gap = (wrapperWidth - (barWidth * totalSubBeats)) / (totalSubBeats - 1);
            }

            for (let i = 0; i < totalSubBeats; i++) {
                const beatBar = document.createElement('div');
                beatBar.classList.add('beat-bar');
                // Determine beat type
                if (i % subBeatsPerMainBeat === 0) {
                    beatBar.classList.add('beat-type-kick'); // Main beat (kick)
                } else if (i % (subBeatsPerMainBeat / 2) === 0) {
                    beatBar.classList.add('beat-type-2'); // Half-beat
                } else {
                    beatBar.classList.add('beat-type-4'); // Quarter-beat
                }

                beatBar.style.width = `${barWidth}px`;
                beatBar.style.marginRight = `${gap}px`; // Apply gap as right margin

                wrapper.appendChild(beatBar);
            }
        }

        /**
         * Updates the visual position and highlighting of beat bars.
         * @param {HTMLAudioElement} audio - The audio element.
         * @param {HTMLElement} beatBarsWrapper - The wrapper containing the beat bars.
         * @param {Array<number>} timeoutsArray - Array to store timeout IDs.
         * @param {number} currentNumMainBeatsDisplayed - Number of main beats currently displayed.
         */
        function updateBeatVisualization(audio, beatBarsWrapper, timeoutsArray, currentNumMainBeatsDisplayed) {
            clearBeatHighlightTimeouts(timeoutsArray); // Clear previous timeouts

            const msPerBeat = (60 / parseFloat(audio.playbackRate * getBPMFromAudio(audio))) * 1000;
            const msPerSubBeat = msPerBeat / SUB_BEATS_PER_MAIN_BEAT;

            const beatVisualizerWidth = beatBarsWrapper.parentElement.offsetWidth;
            const totalSubBeats = beatBarsWrapper.children.length; // Use the actual number of generated bars

            // Calculate total width of all bars and gaps
            let totalBarsWidth = 0;
            for (let i = 0; i < totalSubBeats; i++) {
                const bar = beatBarsWrapper.children[i];
                totalBarsWidth += parseFloat(bar.style.width);
                if (i < totalSubBeats - 1) { // Add gap for all but the last bar
                    totalBarsWidth += parseFloat(bar.style.marginRight);
                }
            }

            // Calculate the width of one sub-beat visually
            const subBeatVisualWidth = totalBarsWidth / totalSubBeats;

            // Calculate how many sub-beats are visible in the wrapper
            const visibleSubBeats = beatVisualizerWidth / subBeatVisualWidth;

            // Calculate the scroll speed (pixels per millisecond)
            const scrollSpeedPxPerMs = (beatVisualizerWidth / (currentNumMainBeatsDisplayed * msPerBeat)) * SUB_BEATS_PER_MAIN_BEAT;

            let lastTime = 0;

            // Determine which state object to use based on the audio element
            const jogState = (audio === audio1) ? jogWheelState1 : jogWheelState2;

            function animateBeatBars(currentTime) {
                if (!audio.paused) {
                    if (!lastTime) lastTime = currentTime;
                    const elapsed = currentTime - lastTime;
                    lastTime = currentTime;

                    // Calculate the position based on audio's current time
                    const currentAudioTime = audio.currentTime * 1000; // in milliseconds
                    const totalMsDisplayed = (currentNumMainBeatsDisplayed * msPerBeat);

                    // Calculate the offset to center the "current beat" at the line indicator
                    // The line indicator is at 50% of the visualizer width.
                    const centerOffsetPx = beatVisualizerWidth / 2;

                    // The actual pixel position for the current audio time, scaled by the visualization speed.
                    const currentPixelPosition = (currentAudioTime % totalMsDisplayed) * (beatVisualizerWidth / totalMsDisplayed);

                    // To keep the current beat at the center, we need to shift the wrapper
                    // by an amount that brings the current beat's visual position to the centerOffsetPx.
                    const wrapperOffset = centerOffsetPx - currentPixelPosition;

                    // Apply the transform to the wrapper
                    beatBarsWrapper.style.transform = `translateX(${wrapperOffset}px)`;

                    // Determine the active and next beats based on audio time
                    const currentSubBeatIndex = Math.floor(currentAudioTime / msPerSubBeat);

                    // Remove all active/next classes first for proper re-highlighting
                    Array.from(beatBarsWrapper.children).forEach(bar => {
                        bar.classList.remove('active-beat', 'next-beat');
                    });

                    // Highlight the current and next beat
                    const activeBar = beatBarsWrapper.children[currentSubBeatIndex % totalSubBeats];
                    const nextBar = beatBarsWrapper.children[(currentSubBeatIndex + 1) % totalSubBeats];

                    if (activeBar) {
                        activeBar.classList.add('active-beat');
                    }
                    if (nextBar) {
                        nextBar.classList.add('next-beat');
                    }
                } else {
                    lastTime = 0; // Reset timer when paused
                }
                jogState.animationFrameId = requestAnimationFrame(animateBeatBars); // Store ID in jogState
            }

            // Cancel any existing animation frame for this track before starting a new one
            if (jogState.animationFrameId) {
                cancelAnimationFrame(jogState.animationFrameId);
            }
            jogState.animationFrameId = requestAnimationFrame(animateBeatBars); // Start new animation
        }

        // Helper to get BPM from audio (assuming you have a way to detect/set it)
        function getBPMFromAudio(audio) {
            // In a real app, you'd get this from audio analysis or metadata.
            // For this mockup, we'll use the value from the BPM slider.
            if (audio.id === 'audio1') {
                return parseFloat(bpmValue1.textContent);
            } else if (audio.id === 'audio2') {
                return parseFloat(bpmValue2.textContent);
            }
            return 120; // Default BPM if not found
        }

        // Add new variables for jog wheel state
        let jogWheelState1 = {
            isDragging: false,
            startAngle: 0,
            startMouseX: 0,
            startMouseY: 0,
            currentRotation: 0,
            lastAngle: 0,
            nudgeTimeout: null,
            audioElement: audio1,
            bpmValueElement: bpmValue1,
            beatBarsWrapper: beatBarsWrapper1,
            timeoutsArray: beatHighlightTimeouts1,
            animationFrameId: null, // For beat visualizer
            animationFrameRotationId: null, // NEW: For jog wheel continuous rotation
            lastRotationTime: 0, // NEW: For continuous rotation calculation
            currentNumMainBeatsDisplayed: currentNumMainBeatsDisplayed1
        };

        let jogWheelState2 = {
            isDragging: false,
            startAngle: 0,
            startMouseX: 0,
            startMouseY: 0,
            currentRotation: 0,
            lastAngle: 0,
            nudgeTimeout: null,
            audioElement: audio2,
            bpmValueElement: bpmValue2,
            beatBarsWrapper: beatBarsWrapper2,
            timeoutsArray: beatHighlightTimeouts2,
            animationFrameId: null, // For beat visualizer
            animationFrameRotationId: null, // NEW: For jog wheel continuous rotation
            lastRotationTime: 0, // NEW: For continuous rotation calculation
            currentNumMainBeatsDisplayed: currentNumMainMainBeatsDisplayed2
        };

        // NEW: Function to update jog wheel rotation based on audio playback
        function updateJogWheelRotation(jogWheelElement, jogState, timestamp) {
            if (jogState.isDragging || jogState.audioElement.paused) {
                jogState.lastRotationTime = timestamp; // Reset last time when paused or dragging
                jogState.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheelElement, jogState, ts));
                return;
            }

            if (!jogState.lastRotationTime) {
                jogState.lastRotationTime = timestamp;
            }

            const elapsed = timestamp - jogState.lastRotationTime;
            const bpm = parseFloat(jogState.bpmValueElement.textContent);
            const playbackRate = jogState.audioElement.playbackRate;

            // Calculate degrees per millisecond for a slower rotation (e.g., 1 revolution every 4 beats)
            const beatsPerRevolution = 4; // Number of main beats for one full jog wheel revolution
            const msPerRevolution = ((60 / bpm) * 1000) * beatsPerRevolution;
            const degreesPerMs = (360 / msPerRevolution) * playbackRate;

            const rotationAmount = degreesPerMs * elapsed;
            jogState.currentRotation += rotationAmount;

            // Keep rotation within a reasonable range to prevent massive numbers
            jogState.currentRotation %= 360;

            jogWheelElement.style.transform = `rotate(${jogState.currentRotation}deg)`;
            jogState.lastRotationTime = timestamp;

            jogState.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheelElement, jogState, ts));
        }


        // Function to calculate angle from center of an element
        function getAngle(event, element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const mouseX = event.clientX || event.touches[0].clientX;
            const mouseY = event.clientY || event.touches[0].clientY;
            return Math.atan2(mouseY - centerY, mouseX - centerX) * (180 / Math.PI);
        }

        // Function to start jog wheel drag
        function startJogDrag(event, jogWheelElement, jogState) {
            jogState.isDragging = true;
            jogState.startAngle = getAngle(event, jogWheelElement);
            jogState.lastAngle = jogState.startAngle;
            jogWheelElement.style.cursor = 'grabbing';
            event.preventDefault(); // Prevent default browser behavior like text selection

            // NEW: Stop automatic rotation when dragging starts
            if (jogState.animationFrameRotationId) {
                cancelAnimationFrame(jogState.animationFrameRotationId);
                jogState.animationFrameRotationId = null;
            }
        }

        // Function to handle jog wheel drag
        function handleJogDrag(event, jogWheelElement, jogState) {
            if (!jogState.isDragging) return;

            const currentAngle = getAngle(event, jogWheelElement);
            let deltaAngle = currentAngle - jogState.lastAngle;

            // Handle angle wrap-around (e.g., going from 170 to -170 degrees)
            if (deltaAngle > 180) {
                deltaAngle -= 360;
            } else if (deltaAngle < -180) {
                deltaAngle += 360;
            }

            jogState.currentRotation += deltaAngle;
            jogWheelElement.style.transform = `rotate(${jogState.currentRotation}deg)`;

            // Audio manipulation (Nudging/Scratching)
            if (!jogState.audioElement.paused) {
                const bpm = parseFloat(jogState.bpmValueElement.textContent);
                // Dynamically get the base BPM for the current track
                const baseBPMForTrack = (jogState.audioElement === audio1) ? initialBaseBPM1 : initialBaseBPM2;

                const nudgeSensitivity = 0.0005; // How much a small rotation affects playback rate
                const scratchThreshold = 5; // Degrees per frame to trigger scratch

                if (Math.abs(deltaAngle) > scratchThreshold) {
                    // Basic scratching effect: jump time
                    const timeJump = deltaAngle * (bpm / 120) * 0.005; // Adjust jump based on BPM and rotation
                    jogState.audioElement.currentTime += timeJump;
                } else {
                    // Nudging effect: temporary pitch bend
                    if (jogState.nudgeTimeout) clearTimeout(jogState.nudgeTimeout);

                    const originalPlaybackRate = bpm / baseBPMForTrack;
                    const newPlaybackRate = originalPlaybackRate + (deltaAngle * nudgeSensitivity);

                    // Clamp playback rate to prevent extreme values
                    jogState.audioElement.playbackRate = Math.max(0.5, Math.min(2.0, newPlaybackRate));

                    jogState.nudgeTimeout = setTimeout(() => {
                        jogState.audioElement.playbackRate = originalPlaybackRate; // Return to original rate
                    }, 100); // Nudge effect duration
                }

                // Update beat visualization after jog wheel interaction
                updateBeatVisualization(jogState.audioElement, jogState.beatBarsWrapper, jogState.timeoutsArray, jogState.currentNumMainBeatsDisplayed);
            }

            jogState.lastAngle = currentAngle;
        }

        // Function to end jog wheel drag
        function endJogDrag(jogWheelElement, jogState) {
            jogState.isDragging = false;
            jogWheelElement.style.cursor = 'grab';
            if (jogState.nudgeTimeout) {
                clearTimeout(jogState.nudgeTimeout);
                // Ensure playback rate returns to normal after drag ends
                const bpm = parseFloat(jogState.bpmValueElement.textContent);
                // Dynamically get the base BPM for the current track
                const baseBPMForTrack = (jogState.audioElement === audio1) ? initialBaseBPM1 : initialBaseBPM2;
                jogState.audioElement.playbackRate = bpm / baseBPMForTrack;
            }
            // NEW: Resume automatic rotation after drag ends, if audio is playing
            if (!jogState.audioElement.paused && !jogState.animationFrameRotationId) {
                jogState.lastRotationTime = performance.now(); // Reset time for smooth restart
                jogState.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheelElement, jogState, ts));
            }
        }

        // Event listeners for Jog Wheel 1
        jogWheel1.addEventListener('mousedown', (e) => startJogDrag(e, jogWheel1, jogWheelState1));
        document.addEventListener('mousemove', (e) => handleJogDrag(e, jogWheel1, jogWheelState1));
        document.addEventListener('mouseup', () => endJogDrag(jogWheel1, jogWheelState1));

        // Add touch events for mobile
        jogWheel1.addEventListener('touchstart', (e) => startJogDrag(e, jogWheel1, jogWheelState1));
        document.addEventListener('touchmove', (e) => handleJogDrag(e, jogWheel1, jogWheelState1));
        document.addEventListener('touchend', () => endJogDrag(jogWheel1, jogWheelState1));

        // Event listeners for Jog Wheel 2
        jogWheel2.addEventListener('mousedown', (e) => startJogDrag(e, jogWheel2, jogWheelState2));
        document.addEventListener('mousemove', (e) => handleJogDrag(e, jogWheel2, jogWheelState2));
        document.addEventListener('mouseup', () => endJogDrag(jogWheel2, jogWheelState2));

        // Add touch events for mobile
        jogWheel2.addEventListener('touchstart', (e) => startJogDrag(e, jogWheel2, jogWheelState2));
        document.addEventListener('touchmove', (e) => handleJogDrag(e, jogWheel2, jogWheelState2));
        document.addEventListener('touchend', () => endJogDrag(jogWheel2, jogWheelState2));

        // Event Listeners for Play/Pause
        playPause1.addEventListener('click', () => {
            if (audio1.paused) {
                audio1.play();
                playPause1.innerHTML = '⏸️ PAUSE A';
                // Using kickPulse1 (which is beatVisualizer1) as the target for the kick pulse effect
                startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', parseFloat(bpmValue1.textContent));
                updateBeatVisualization(audio1, beatBarsWrapper1, beatHighlightTimeouts1, currentNumMainBeatsDisplayed1);
                // NEW: Start jog wheel rotation when playing
                jogWheelState1.lastRotationTime = performance.now(); // Reset time
                jogWheelState1.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel1, jogWheelState1, ts));
            } else {
                audio1.pause();
                playPause1.innerHTML = '▶️ PLAY A';
                clearInterval(kickInterval1);
                cancelAnimationFrame(jogWheelState1.animationFrameId); // For beat visualizer
                // NEW: Stop jog wheel rotation when paused
                if (jogWheelState1.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState1.animationFrameRotationId);
                    jogWheelState1.animationFrameRotationId = null;
                }
                clearBeatHighlightTimeouts(beatHighlightTimeouts1);
            }
        });

        playPause2.addEventListener('click', () => {
            if (audio2.paused) {
                audio2.play();
                playPause2.innerHTML = '⏸️ PAUSE B';
                // Using kickPulse2 (which is beatVisualizer2) as the target for the kick pulse effect
                startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', parseFloat(bpmValue2.textContent));
                updateBeatVisualization(audio2, beatBarsWrapper2, beatHighlightTimeouts2, currentNumMainMainBeatsDisplayed2);
                // NEW: Start jog wheel rotation when playing
                jogWheelState2.lastRotationTime = performance.now(); // Reset time
                jogWheelState2.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel2, jogWheelState2, ts));
            } else {
                audio2.pause();
                playPause2.innerHTML = '▶️ PLAY B';
                clearInterval(kickInterval2);
                cancelAnimationFrame(jogWheelState2.animationFrameId); // For beat visualizer
                // NEW: Stop jog wheel rotation when paused
                if (jogWheelState2.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState2.animationFrameRotationId);
                    jogWheelState2.animationFrameRotationId = null;
                }
                clearBeatHighlightTimeouts(beatHighlightTimeouts2);
            }
        });

        // Event Listeners for CUE buttons
        cue1Button.addEventListener('click', () => {
            audio1.pause(); // Pause on CUE
            playPause1.innerHTML = '▶️ PLAY A';
            clearInterval(kickInterval1);
            cancelAnimationFrame(jogWheelState1.animationFrameId);
            if (jogWheelState1.animationFrameRotationId) { // Stop jog wheel rotation
                cancelAnimationFrame(jogWheelState1.animationFrameRotationId);
                jogWheelState1.animationFrameRotationId = null;
            }
            clearBeatHighlightTimeouts(beatHighlightTimeouts1);

            audio1.currentTime = cuePoint1; // Go to cue point
            console.log(`CUE L set to: ${cuePoint1.toFixed(2)}s. Now at CUE L.`);
        });

        cue2Button.addEventListener('click', () => {
            audio2.pause(); // Pause on CUE
            playPause2.innerHTML = '▶️ PLAY B';
            clearInterval(kickInterval2);
            cancelAnimationFrame(jogWheelState2.animationFrameId);
            if (jogWheelState2.animationFrameRotationId) { // Stop jog wheel rotation
                cancelAnimationFrame(jogWheelState2.animationFrameRotationId);
                jogWheelState2.animationFrameRotationId = null;
            }
            clearBeatHighlightTimeouts(beatHighlightTimeouts2);

            audio2.currentTime = cuePoint2; // Go to cue point
            console.log(`CUE R set to: ${cuePoint2.toFixed(2)}s. Now at CUE R.`);
        });


        // "Play All" Debug Button
        debugPlayAllButton.addEventListener('click', () => {
            const isAudio1Playing = !audio1.paused;
            const isAudio2Playing = !audio2.paused;

            if (isAudio1Playing && isAudio2Playing) {
                // Both playing, stop both
                audio1.pause();
                audio2.pause();
                playPause1.innerHTML = '▶️ PLAY A';
                playPause2.innerHTML = '▶️ PLAY B';
                clearInterval(kickInterval1);
                clearInterval(kickInterval2);
                cancelAnimationFrame(jogWheelState1.animationFrameId);
                cancelAnimationFrame(jogWheelState2.animationFrameId);
                if (jogWheelState1.animationFrameRotationId) { // Stop jog wheel rotation
                    cancelAnimationFrame(jogWheelState1.animationFrameRotationId);
                    jogWheelState1.animationFrameRotationId = null;
                }
                if (jogWheelState2.animationFrameRotationId) { // Stop jog wheel rotation
                    cancelAnimationFrame(jogWheelState2.animationFrameRotationId);
                    jogWheelState2.animationFrameRotationId = null;
                }
                clearBeatHighlightTimeouts(beatHighlightTimeouts1);
                clearBeatHighlightTimeouts(beatHighlightTimeouts2);
            } else {
                // At least one is paused, play both from cue points
                if (audio1.paused) {
                    audio1.currentTime = cuePoint1; // Go to cue point
                    audio1.play();
                    playPause1.innerHTML = '⏸️ PAUSE A';
                    startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', parseFloat(bpmValue1.textContent));
                    updateBeatVisualization(audio1, beatBarsWrapper1, beatHighlightTimeouts1, currentNumMainBeatsDisplayed1);
                    jogWheelState1.lastRotationTime = performance.now();
                    jogWheelState1.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel1, jogWheelState1, ts));
                }
                if (audio2.paused) {
                    audio2.currentTime = cuePoint2; // Go to cue point
                    audio2.play();
                    playPause2.innerHTML = '⏸️ PAUSE B';
                    startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', parseFloat(bpmValue2.textContent));
                    updateBeatVisualization(audio2, beatBarsWrapper2, beatHighlightTimeouts2, currentNumMainMainBeatsDisplayed2);
                    jogWheelState2.lastRotationTime = performance.now();
                    jogWheelState2.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel2, jogWheelState2, ts));
                }
            }
        });

        // Event Listeners for BPM sliders
        bpmSlider1.addEventListener('input', () => {
            const newBPM = parseFloat(bpmSlider1.value);
            bpmValue1.textContent = newBPM.toFixed(1);
            audio1.playbackRate = newBPM / initialBaseBPM1; // Adjust playback rate based on original BPM
            if (!audio1.paused) {
                startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', newBPM);
                updateBeatVisualization(audio1, beatBarsWrapper1, beatHighlightTimeouts1, currentNumMainBeatsDisplayed1);
                // NEW: Restart jog wheel rotation to reflect new BPM/playback rate
                if (jogWheelState1.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState1.animationFrameRotationId);
                }
                jogWheelState1.lastRotationTime = performance.now();
                jogWheelState1.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel1, jogWheelState1, ts));
            }
        });

        bpmSlider2.addEventListener('input', () => {
            const newBPM = parseFloat(bpmSlider2.value);
            bpmValue2.textContent = newBPM.toFixed(1);
            audio2.playbackRate = newBPM / initialBaseBPM2; // Adjust playback rate based on original BPM
            if (!audio2.paused) {
                startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', newBPM);
                updateBeatVisualization(audio2, beatBarsWrapper2, beatHighlightTimeouts2, currentNumMainMainBeatsDisplayed2);
                // NEW: Restart jog wheel rotation to reflect new BPM/playback rate
                if (jogWheelState2.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState2.animationFrameRotationId);
                }
                jogWheelState2.lastRotationTime = performance.now();
                jogWheelState2.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel2, jogWheelState2, ts));
            }
        });

        // Event Listeners for SYNC buttons (simple BPM matching for mockup)
        sync1.addEventListener('click', () => {
            const targetBPM = parseFloat(bpmValue2.textContent);
            bpmSlider1.value = targetBPM.toFixed(1);
            bpmValue1.textContent = targetBPM.toFixed(1);
            audio1.playbackRate = targetBPM / initialBaseBPM1;
            if (!audio1.paused) {
                startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', targetBPM);
                updateBeatVisualization(audio1, beatBarsWrapper1, beatHighlightTimeouts1, currentNumMainBeatsDisplayed1);
                // NEW: Restart jog wheel rotation to reflect new BPM/playback rate
                if (jogWheelState1.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState1.animationFrameRotationId);
                }
                jogWheelState1.lastRotationTime = performance.now();
                jogWheelState1.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel1, jogWheelState1, ts));
            }
        });

        sync2.addEventListener('click', () => {
            const targetBPM = parseFloat(bpmValue1.textContent);
            bpmSlider2.value = targetBPM.toFixed(1);
            bpmValue2.textContent = targetBPM.toFixed(1);
            audio2.playbackRate = targetBPM / initialBaseBPM2;
            if (!audio2.paused) {
                startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', targetBPM);
                updateBeatVisualization(audio2, beatBarsWrapper2, beatHighlightTimeouts2, currentNumMainMainBeatsDisplayed2);
                // NEW: Restart jog wheel rotation to reflect new BPM/playback rate
                if (jogWheelState2.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState2.animationFrameRotationId);
                }
                jogWheelState2.lastRotationTime = performance.now();
                jogWheelState2.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel2, jogWheelState2, ts));
            }
        });

        // Crossfader logic
        crossfader.addEventListener('input', () => {
            const value = parseFloat(crossfader.value);
            audio1.volume = 1 - value;
            audio2.volume = value;

            // Calculate glow intensity based on volume
            const glowIntensityLeft = (1 - value).toFixed(2); // Invert for left channel
            const glowIntensityRight = value.toFixed(2); // Direct for right channel

            // Apply glow to left beat visualizer
            beatVisualizer1.classList.add('glow-left');
            beatVisualizer1.style.setProperty('--glow-intensity-left', glowIntensityLeft);
            if (glowIntensityLeft == 0) {
                beatVisualizer1.classList.remove('glow-left');
            }

            // Apply glow to right beat visualizer
            beatVisualizer2.classList.add('glow-right');
            beatVisualizer2.style.setProperty('--glow-intensity-right', glowIntensityRight);
            if (glowIntensityRight == 0) {
                beatVisualizer2.classList.remove('glow-right');
            }
        });

        // Initial setup for beat visualization
        const initialVisualizerWidth = beatVisualizer1.offsetWidth || 200; 
        generateBeatBars(beatBarsWrapper1, TOTAL_GENERATED_SUB_BEATS / SUB_BEATS_PER_MAIN_BEAT, SUB_BEATS_PER_MAIN_BEAT, initialVisualizerWidth);
        generateBeatBars(beatBarsWrapper2, TOTAL_GENERATED_SUB_BEATS / SUB_BEATS_PER_MAIN_BEAT, SUB_BEATS_PER_MAIN_BEAT, initialVisualizerWidth);

        // Zoom functionality
        function applyZoom(trackNum, direction) {
            let currentZoomLevelIndex;
            let currentNumMainBeatsDisplayed;
            let beatBarsWrapper;
            let audio;
            let timeoutsArray;
            let jogState;

            if (trackNum === 1) {
                currentZoomLevelIndex = ZOOM_LEVELS.indexOf(currentNumMainBeatsDisplayed1);
                currentNumMainBeatsDisplayed = currentNumMainBeatsDisplayed1;
                beatBarsWrapper = beatBarsWrapper1;
                audio = audio1;
                timeoutsArray = beatHighlightTimeouts1;
                jogState = jogWheelState1;
            } else {
                currentZoomLevelIndex = ZOOM_LEVELS.indexOf(currentNumMainMainBeatsDisplayed2);
                currentNumMainMainBeatsDisplayed = currentNumMainMainBeatsDisplayed2;
                beatBarsWrapper = beatBarsWrapper2;
                audio = audio2;
                timeoutsArray = beatHighlightTimeouts2;
                jogState = jogWheelState2;
            }

            if (direction === 'in' && currentZoomLevelIndex < ZOOM_LEVELS.length - 1) {
                currentZoomLevelIndex++;
            } else if (direction === 'out' && currentZoomLevelIndex > 0) {
                currentZoomLevelIndex--;
            }
            
            const newNumMainBeatsDisplayed = ZOOM_LEVELS[currentZoomLevelIndex];
            
            if (trackNum === 1) {
                currentNumMainBeatsDisplayed1 = newNumMainBeatsDisplayed;
                jogWheelState1.currentNumMainBeatsDisplayed = newNumMainBeatsDisplayed;
            } else {
                currentNumMainMainBeatsDisplayed2 = newNumMainBeatsDisplayed;
                jogWheelState2.currentNumMainBeatsDisplayed = newNumMainBeatsDisplayed;
            }
            
            generateBeatBars(beatBarsWrapper, TOTAL_GENERATED_SUB_BEATS / SUB_BEATS_PER_MAIN_BEAT, SUB_BEATS_PER_MAIN_BEAT, beatBarsWrapper.parentElement.offsetWidth);
            if (!audio.paused) {
                updateBeatVisualization(audio, beatBarsWrapper, timeoutsArray, newNumMainBeatsDisplayed);
            }
        }

        zoomIn1.addEventListener('click', () => applyZoom(1, 'in'));
        zoomOut1.addEventListener('click', () => applyZoom(1, 'out'));
        zoomIn2.addEventListener('click', () => applyZoom(2, 'in'));
        zoomOut2.addEventListener('click', () => applyZoom(2, 'out'));

        // NEW: Function to set up the SVG trace properties
        function setupJogTrace(circleElement) {
            const radius = parseFloat(circleElement.getAttribute('r'));
            const circumference = 2 * Math.PI * radius;
            
            // "6 bars" means roughly 1/6th of the circle's circumference
            const dashLength = circumference / 6;
            const gapLength = circumference - dashLength;

            circleElement.style.strokeDasharray = `${dashLength} ${gapLength}`;
            // Position the trace so its center is at the top (after SVG rotation -90deg)
            // The -90deg transform on SVG makes the 0-degree point of the circle (usually right-most)
            // appear at the top. So, to center a dash of length `dashLength` at this 0-degree point,
            // we need to offset it by half its length.
            circleElement.style.strokeDashoffset = `${-dashLength / 2}`;
        }

        // Call setup for both jog traces when the script loads
        setupJogTrace(jogTraceCircle1);
        setupJogTrace(jogTraceCircle2);


        // ---------- NEW: loadSong function definition ----------
        /**
         * Loads a song into a deck, updating audio source, BPM, and beat visualization.
         * @param {HTMLAudioElement} audioElement - The audio element for the deck.
         * @param {HTMLElement} songNameElement - The element to display the song name (not present in HTML, so ignored for now).
         * @param {HTMLElement} bpmValueElement - The element to display the BPM value.
         * @param {string} newSongName - The name of the new song.
         * @param {number} newBPM - The BPM of the new song.
         * @param {string} newFileUrl - The URL of the new audio file.
         * @param {HTMLElement} beatBarsWrapper - The wrapper for beat visualization bars.
         * @param {Array<number>} beatHighlightTimeouts - Array to store beat highlight timeouts.
         * @param {string} animationFrameIdVarName - The name of the variable storing the beat visualization animation frame ID.
         * @param {number} currentNumMainBeatsDisplayed - The current zoom level for beat visualization.
         */
        function loadSong(audioElement, songNameElement, bpmValueElement, newSongName, newBPM, newFileUrl, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, currentNumMainBeatsDisplayed) {
            // Update audio source
            audioElement.src = newFileUrl;
            audioElement.load(); // Load the new audio

            // Update BPM display and slider
            bpmValueElement.textContent = newBPM.toFixed(1);

            // Dynamically update the initialBaseBPM for the specific track
            if (audioElement === audio1) {
                initialBaseBPM1 = newBPM;
                setupBPMSlider(bpmSlider1, newBPM);
            } else if (audioElement === audio2) {
                initialBaseBPM2 = newBPM;
                setupBPMSlider(bpmSlider2, newBPM);
            }

            // (Optional) Update song name display if you add elements for it in your HTML
            // if (songNameElement) {
            //     songNameElement.textContent = newSongName;
            // }

            // Reset cue point to 0 when loading a new song
            if (audioElement === audio1) {
                cuePoint1 = 0;
            } else if (audioElement === audio2) {
                cuePoint2 = 0;
            }

            // Stop any existing animation/intervals for the old song
            audioElement.pause();
            if (audioElement === audio1) {
                playPause1.innerHTML = '▶️ PLAY A';
                clearInterval(kickInterval1);
                cancelAnimationFrame(jogWheelState1.animationFrameId);
                if (jogWheelState1.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState1.animationFrameRotationId);
                    jogWheelState1.animationFrameRotationId = null;
                }
                clearBeatHighlightTimeouts(beatHighlightTimeouts1);
            } else if (audioElement === audio2) {
                playPause2.innerHTML = '▶️ PLAY B';
                clearInterval(kickInterval2);
                cancelAnimationFrame(jogWheelState2.animationFrameId);
                if (jogWheelState2.animationFrameRotationId) {
                    cancelAnimationFrame(jogWheelState2.animationFrameRotationId);
                    jogWheelState2.animationFrameRotationId = null;
                }
                clearBeatHighlightTimeouts(beatHighlightTimeouts2);
            }

            // Regenerate beat bars for the new track (important if BPM changes significantly affects visualization)
            // You might want to delay this slightly or ensure audio is loaded.
            generateBeatBars(beatBarsWrapper, TOTAL_GENERATED_SUB_BEATS / SUB_BEATS_PER_MAIN_BEAT, SUB_BEATS_PER_MAIN_BEAT, beatBarsWrapper.parentElement.offsetWidth);
            // Don't start updateBeatVisualization until the user plays the track
            console.log(`Song loaded: ${newSongName} (BPM: ${newBPM}, File: ${newFileUrl})`);
        }
        // ---------- END NEW: loadSong function definition ----------


// ---------- FUNCIÓN PARA ESCUCHAR EL MENSAJE DE MÚSICA ----------
        window.addEventListener('message', (event) => {
            // *** IMPORTANTE: Verifica el origen del mensaje en un entorno de producción para evitar ataques XSS ***
            // Por ejemplo, si tu página principal (el emisor) está en 'http://localhost:8000', usa:
            // if (event.origin !== "http://localhost:8000") {
            //     console.warn('Mensaje recibido de un origen no autorizado:', event.origin);
            //     return;
            // }

            if (event.data && event.data.type === 'sapitoGameMusicData') {
                const musicData = event.data.musicTracks;
                if (musicData && musicData.length >= 2) {
                    console.log('DJ App (new jog): Recibida información de música:', musicData);

                    // Here's where you use the song data to load it into your players
                    // You will need references to your audio elements and visualization elements

                    // Load the first song (Deck 1)
                    // Note: songName1 is not an existing element in your HTML, consider adding it if you want to display the song name.
                    loadSong(audio1, null, bpmValue1, musicData[0].name, musicData[0].bpm, musicData[0].file, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1);
                    
                    // Load the second song (Deck 2)
                    loadSong(audio2, null, bpmValue2, musicData[1].name, musicData[1].bpm, musicData[1].file, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2);

                    // Adicionalmente, si tienes lógicas de animación o juego que dependen de la carga,
                    // como las que estaban en 2jog - Sapito v3 - Music-fron-main.html:
                    // These should generally only start when the user presses play, but kept them for now if they are intended to run on load.
                    // If these are meant to only run when the user explicitly plays the song, remove them from here.
                    startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', parseFloat(bpmValue1.textContent));
                    jogWheelState1.lastRotationTime = performance.now();
                    jogWheelState1.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel1, jogWheelState1, ts));

                    startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', parseFloat(bpmValue2.textContent));
                    jogWheelState2.lastRotationTime = performance.now();
                    jogWheelState2.animationFrameRotationId = requestAnimationFrame((ts) => updateJogWheelRotation(jogWheel2, jogWheelState2, ts));

                    // If there is any global game dynamics update
                    // Make sure updateAllPlatformDynamics is defined in this file
                    if (typeof updateAllPlatformDynamics === 'function') {
                        updateAllPlatformDynamics();
                    } else {
                        console.warn('Función updateAllPlatformDynamics no encontrada en check 6 - all working - new jog.html');
                    }

                } else {
                    console.warn('DJ App (new jog): Recibida información de música, pero no hay suficientes canciones para ambas pistas. Usando valores predeterminados si los hay.');
                }
            } else {
                // console.log('DJ App (new jog): Mensaje recibido pero no es del tipo esperado:', event.data);
            }
        });
        // ---------- FIN DE LA FUNCIÓN PARA ESCUCHAR EL MENSAJE ----------


        // Initial call to checkSyncedKicks to start the continuous check
        requestAnimationFrame(checkSyncedKicks);

        // Initial crossfader dispatch to set initial volumes and glows
	    crossfader.dispatchEvent(new Event('input'));

    </script>
</body>
</html>
