<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DJ App Mockup con Plataformer Minijuego</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            background-color: #1a202c; /* Fondo oscuro para el body */
            color: #e2e8f0; /* Color de texto claro */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ocupa al menos el 100% de la altura de la ventana */
            overflow: hidden; /* Prevent scrollbars */
        }
        /* Estilos base del frame del teléfono */
        .phone-frame {
            width: 375px;
            height: 700px;
            background-color: #1a202c;
            border-radius: 40px;
            box-shadow: 0 0 0 8px #2d3748,
                                 0 0 0 12px #1a202c,
                                 0 20px 50px rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
            flex-direction: column;
            padding-bottom: 50px;
            display: flex; /* Ensure flex for internal layout */
        }

        .notch {
            width: 120px;
            height: 25px;
            background-color: #1a202c;
            border-bottom-left-radius: 15px;
            border-bottom-right-radius: 15px;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
        }

        /* Estilos de la onda de audio (simulada) */
        .waveform {
            height: 40px;
            background: repeating-linear-gradient(90deg,
                #2d3748 0%, #2d3748 5%,
                #4a5568 5%, #4a5568 10%,
                #2d3748 10%, #2d3748 15%,
                #4a5568 15%, #4a5568 20%,
                #2d3748 20%, #2d3748 25%,
                #4a5568 25%, #4a5568 30%,
                #2d3748 30%, #2d3748 35%,
                #4a5568 35%, #4a5568 40%,
                #2d3748 40%, #2d3748 45%,
                #4a5568 45%, #4a5568 50%
            );
            background-size: 200px 100%;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            flex-grow: 1;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
        }

        .waveform.red {
            background: repeating-linear-gradient(90deg,
                #374151 0%, #374151 5%,
                #4b5563 5%, #4b5563 10%,
                #374151 10%, #374151 15%,
                #4b5563 15%, #4b5563 20%,
                #374151 20%, #374151 25%,
                #4b5563 25%, #4b5563 30%,
                #374151 30%, #374151 35%,
                #4b5563 35%, #4b5563 40%,
                #374151 40%, #374151 45%,
                #4b5563 45%, #4b5563 50%
            );
            background-size: 200px 100%;
        }

        .waveform-progress {
            height: 100%;
            background-color: rgba(66, 153, 225, 0.7);
            position: absolute;
            left: 0;
            top: 0;
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 8px;
        }

        /* Estilos del jog wheel */
        .jog-wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 4px solid #4a5568;
            background-color: #2d3748;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.6);
            /* Removed transition here, handled by JS requestAnimationFrame for smoothness */
            z-index: 10;
        }

        .jog-wheel:active {
            cursor: grabbing;
        }

        /* NEW: Styles for the SVG trace */
        .jog-trace-svg {
            position: absolute; /* Position it relative to jog-wheel */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg); /* Rotate SVG to start trace at top */
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.7)); /* Glow effect */
        }

        /* Removed old .jog-indicator and @keyframes throb */

        /* Estilos del contenedor del visualizador de kick */
        .kick-visualizer-container {
            width: 100px;
            height: 40px;
            border-radius: 10px;
            background-color: #374151;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .kick-pulse-element {
            width: 40px;
            height: 40px;
            background-color: #4299e1;
            border-radius: 5px;
            opacity: 0;
            transform: scale(0.5);
            transition: opacity 0.05s ease-out, transform 0.05s ease-out;
        }

        .kick-pulse-element.active {
            transform: scale(1.1);
            opacity: 1;
        }

        /* Indicador de kicks sincronizados */
        #synced-kicks-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(74, 222, 128, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 30;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #synced-kicks-indicator.active {
            opacity: 1;
        }

        /* Estilo para el botón de debug */
        #debug-play-all {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #6b7280;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            z-index: 50;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease-in-out;
        }

        #debug-play-all:hover {
            background-color: #4a5568;
        }

        /* Estilo para los sliders verticales (BPM faders) */
        .vertical-fader {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 12px;
            background: #4a5568;
            outline: none;
            border-radius: 6px;
            z-index: 1;
            transform: rotate(-90deg);
            transform-origin: center;
            margin: 0;
        }

        .vertical-fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 20px;
            background: #63b3ed;
            border-radius: 4px;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .vertical-fader::-moz-range-thumb {
            width: 30px;
            height: 20px;
            background: #63b3ed;
            border-radius: 4px;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Adjusted styles for elements that were in fader-group-abs, now individual */
       .bpm-label-abs { /* New class for the BPM text element */
            font-size: 0.875rem; /* text-sm */
            font-weight: 600;
            color: #90cdf4;
            /* margin-bottom: 4px; */ /* Removed as individual positioning */
        }

        .bpm-value {
            font-size: 1.125rem; /* text-lg */
            /* margin-bottom: 8px; */ /* Removed as individual positioning */
        }

        .play-button, .cue-button {
            padding: 8px 12px;
            font-size: 0.875rem;
            border-radius: 9999px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease-in-out;
            width: 90px;
            text-align: center;
        }
        .play-button {
            background-color: #63b3ed;
            color: white;
        }
        .play-button:hover {
            background-color: #4299e1;
        }

        .cue-button {
            background-color: #f6ad55;
            color: white;
        }
        .cue-button:hover {
            background-color: #ed8936;
        }

        /* Styles for Crossfader */
        .crossfader-container {
            width: 100%;
            padding: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .crossfader-container input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            max-width: 250px;
            height: 10px;
            background: #4a5568;
            outline: none;
            border-radius: 5px;
        }

        .crossfader-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #63b3ed;
            border-radius: 50%;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .crossfader-container input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #63b3ed;
            border-radius: 50%;
            cursor: grab;
            border: 2px solid #a0aec0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* NUEVOS ESTILOS PARA LA VISUALIZACIÓN DE BEATS */
        .beat-visualization-container {
            width: 300px;
            height: 50px;
            background-color: #2d3748;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            padding: 0;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            z-index: 5;
            justify-content: center;
            transition: box-shadow 0.1s ease-out; /* Add transition for smooth glow */
        }

        .beat-visualization-container.glow-left {
            box-shadow: 0 0 25px 5px rgba(229, 62, 62, var(--glow-intensity-left, 0)); /* Blue glow for left */
        }

        .beat-visualization-container.glow-right {
            box-shadow: 0 0 25px 5px rgba(66, 153, 225, var(--glow-intensity-right, 0)); /* Red glow for right */
        }

        .beat-bars-wrapper {
            display: flex;
            height: 100%;
            align-items: center;
            will-change: transform;
        }

        .beat-bar {
            border-radius: 3px;
            opacity: 0.5;
            transition: background-color 0.1s ease-out, opacity 0.1s ease-out, transform 0.1s ease-out, height 0.1s ease-out;
            flex-shrink: 0;
            margin: 0 1px;
        }

        .beat-bar.beat-type-kick {
            background-color: #4299e1;
            height: 35px;
            transform: scale(1.0);
        }

        .beat-bar.beat-type-2,
        .beat-bar.beat-type-3,
        .beat-bar.beat-type-4 {
            background-color: #a0aec0;
            height: 25px;
            transform: scale(0.7);
        }

        .beat-bar.active-beat {
            background-color: #e53e3e;
            opacity: 1;
            transform: scale(1.3);
            height: 40px;
        }

        .beat-bar.next-beat {
            background-color: #f6e05e;
            opacity: 0.9;
            transform: scale(1.1);
            height: 30px;
        }

        .line-indicator {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            height: 100%;
            width: 2px;
            background-color: #e53e3e;
            z-index: 10;
            box-shadow: 0 0 5px rgba(229, 62, 62, 0.7);
        }

        /* Styles for zoom buttons */
        .zoom-buttons {
            display: flex;
            gap: 5px;
        }

        .zoom-button {
            background-color: #4a5568;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }

        .zoom-button:hover {
            background-color: #2d3748;
        }

        /* NEW: Visualization Frame Styles */
        .visualization-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%; /* Changed from 100% to 50% */
            background-color: rgba(26, 32, 44, 0.95); /* Semi-transparent dark background */
            z-index: 40; /* Above most elements, below notch and indicator */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Keeps content centered vertically within the 50% height */
            color: #cbd5e0; /* Light text color */
            font-size: 1.2rem;
            font-weight: bold;
            backdrop-filter: blur(5px); /* Optional: blur effect */
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none; /* Allows clicks to pass through when hidden */
        }

        .visualization-frame.active {
            opacity: 1;
            pointer-events: auto; /* Re-enable clicks when active */
        }

        /* Minigame CSS - Platform Game */
        #platform-game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Reduced gap */
            padding: 10px; /* Reduced padding */
            background-color: #2d3748; /* Darker background for minigame container */
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            width: 90%; /* Adjust width to fit phone frame */
            max-width: 320px; /* Max width to fit in phone frame */
            height: 90%;
            max-height: 400px; /* Max height for minigame area */
        }

        #platform-game-area {
            position: relative;
            width: 100%; /* Fill parent container */
            flex-grow: 1; /* Take available space */
            background-color: #87ceeb; /* Sky Blue */
            border: 2px solid #4682b4; /* Steel Blue */
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5);
        }

        #platformGameCanvas {
            background-color: transparent; /* Canvas will draw elements, area has background */
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #game-ball {
            position: absolute;
            width: 20px; /* 2 * radius */
            height: 20px; /* 2 * radius */
            background-color: #FFD700; /* Gold */
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(246, 224, 94, 0.7);
            bottom: 0; /* Positioned by JS */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%);
            z-index: 10; /* Ensure ball is above platforms */
        }

        .minigame-controls {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .minigame-control-button {
            padding: 8px 15px; /* Smaller padding for better fit */
            background-color: #63b3ed; /* Blue */
            color: white;
            border-radius: 6px; /* Slightly smaller radius */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 3px #4299e1; /* Darker blue shadow */
        }

        .minigame-control-button:active {
            background-color: #4299e1;
            transform: translateY(2px);
            box-shadow: 0 1px #4299e1;
        }

        #minigameMessageBox { /* New ID for minigame specific message box */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            z-index: 1001; /* Above game elements */
            display: none;
            font-size: 1.2em;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            width: 80%;
        }
    </style>
</head>
<body>
    <div class="phone-frame">
        <div class="notch"></div>

        <div class="bg-gray-900 text-gray-100 font-inter flex flex-col items-center justify-start w-full h-full">
            <div class="relative w-full p-4 flex items-center justify-between z-10">
                <button class="text-gray-400 hover:text-white text-2xl font-bold">X</button>
                <div class="h-4 bg-green-500 rounded-full w-3/4 mx-auto"></div>
            </div>




        </div>

        <div id="synced-kicks-indicator" class="absolute" style="top: 100px; left: 50%; transform: translateX(-50%);">¡Kicks Sincronizados!</div>

        <div id="jog-wheel-1" class="jog-wheel absolute" style="top: 350px; left: -70px;">
            <svg class="jog-trace-svg" viewBox="0 0 200 200">
                <defs>
                    <linearGradient id="gradientTrace" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(255,255,255,0.0)" />
                        <stop offset="30%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="70%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="100%" style="stop-color:rgba(255,255,255,0.0)" />
                    </linearGradient>
                </defs>
                <circle id="jog-trace-circle-1" cx="100" cy="100" r="90" fill="none" stroke="url(#gradientTrace)" stroke-width="10" stroke-linecap="round"></circle>
            </svg>
        </div>
        <div id="jog-wheel-2" class="jog-wheel absolute" style="top: 350px; right: -70px;">
            <svg class="jog-trace-svg" viewBox="0 0 200 200">
                <defs>
                    <linearGradient id="gradientTrace" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(255,255,255,0.0)" />
                        <stop offset="30%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="70%" style="stop-color:rgba(255,255,255,0.7)" />
                        <stop offset="100%" style="stop-color:rgba(255,255,255,0.0)" />
                    </linearGradient>
                </defs>
                <circle id="jog-trace-circle-2" cx="100" cy="100" r="90" fill="none" stroke="url(#gradientTrace)" stroke-width="10" stroke-linecap="round"></circle>
            </svg>
        </div>

        <div id="beat-visualizer-1" class="beat-visualization-container absolute" style="top: 180px; left: 35px;">
            <div class="line-indicator"></div>
            <div id="beat-bars-wrapper-1" class="beat-bars-wrapper"></div>
            <div class="absolute left-0 top-1/2 -translate-y-1/2 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-r-md z-20">C1</div>
        </div>
        <div class="zoom-buttons absolute" style="top: 130px; left: 35px;">
            <button id="zoom-out-1" class="zoom-button">-</button>
            <button id="zoom-in-1" class="zoom-button">+</button>
        </div>
       
        <h2 class="text-sm font-semibold text-blue-300 bpm-label-abs absolute" style="top: 80px; left: 45px;">BPM: <span id="bpm-value-1" class="bpm-value">145.0</span></h2>
        <button id="sync-1" class="bg-purple-600 hover:bg-purple-700 text-white text-xs font-bold py-1 px-2 rounded-md shadow-lg transition-all duration-200 absolute" style="top: 480px; left: 55px;">
            SYNC
        </button>
        <input type="range" id="bpm-slider-1" class="vertical-fader absolute" style="top: 440px; left: 80px; transform: rotate(-90deg);">


        <div id="beat-visualizer-2" class="beat-visualization-container absolute" style="top: 250px; left: 35px;">
            <div class="line-indicator"></div>
            <div id="beat-bars-wrapper-2" class="beat-bars-wrapper"></div>
            <div class="absolute right-0 top-1/2 -translate-y-1/2 bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded-l-md z-20">C2</div>
        </div>
        <div class="zoom-buttons absolute" style="top: 130px; right: 35px;">
            <button id="zoom-out-2" class="zoom-button">-</button>
            <button id="zoom-in-2" class="zoom-button">+</button>
        </div>

        <h2 class="text-sm font-semibold text-blue-300 bpm-label-abs absolute" style="top: 80px; right: 45px;">BPM: <span id="bpm-value-2" class="bpm-value">130.0</span></h2>
        <button id="sync-2" class="bg-purple-600 hover:bg-purple-700 text-white text-xs font-bold py-1 px-2 rounded-md shadow-lg transition-all duration-200 absolute" style="top: 480px; right: 55px;">
            SYNC
        </button>
        <input type="range" id="bpm-slider-2" class="vertical-fader absolute" style="top: 440px; right: 80px; transform: rotate(-90deg);">


        <div class="play-cue-buttons-abs absolute" style="bottom: 95px; left: 50%; transform: translateX(-50%); display: flex; gap: 180px;">
            <button id="cue-1" class="cue-button">CUE L</button>
            <button id="cue-2" class="cue-button">CUE R</button>
        </div>

        <div class="play-cue-buttons-abs absolute" style="bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 180px;">
            <button id="play-pause-1" class="play-button">▶️ PLAY A</button>
            <button id="play-pause-2" class="play-button">▶️ PLAY B</button>
        </div>

        <div class="absolute" style="bottom: 125px; left: 50%; transform: translateX(-50%); display: flex; gap: 180px;">
            <div class="flex flex-col items-center gap-2">
                <button id="prev-1" class="play-button">⏮️ Prev</button>
                <button id="next-1" class="play-button">Next ▶️</button>
            </div>
            <div class="flex flex-col items-center gap-2">
                <button id="prev-2" class="play-button">⏮️ Prev</button>
                <button id="next-2" class="play-button">Next ▶️</button>
            </div>
        </div>

        <div class="crossfader-container absolute" style="bottom: 60px; left: 0; right: 0; width: 100%; max-width: 180px; margin: 0 auto;">
            <label for="crossfader" class="sr-only">Crossfader</label>
            <input type="range" id="crossfader" min="0" max="1" value="0.5" step="0.01">
        </div>

        <button id="debug-play-all" class="absolute" style="bottom: 0px; left: 50%; transform: translateX(-50%);">
            ▶️▶️ Play All
        </button>

        <div id="visualization-frame" class="visualization-frame">
            <div id="platform-game-container">
                <h2 class="text-xl text-blue-300 font-bold mb-2">Platform Jump</h2>
                <div id="platform-game-area">
                    <canvas id="platformGameCanvas"></canvas>
                    <div id="minigameMessageBox"></div> </div>
                <div id="game-score" class="text-lg font-bold text-gray-200">Score: 0</div>
                <div class="minigame-controls">
                    <button id="minigame-start-button" class="minigame-control-button">▶️ Start Game</button>
                </div>
            </div>
        </div>

        <div class="absolute" style="bottom: 120px; left: 50%; transform: translateX(-50%); z-index: 60;">
            <label for="toggleVisualization" class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="toggleVisualization" class="sr-only peer">
                <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:st`art-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                <span class="ms-3 text-sm font-medium text-gray-900 dark:text-gray-300">Show Visualization</span>
            </label>
        </div>

    </div>

    <audio id="audio1" src="https://raw.githubusercontent.com/DjLess/MP3_repo/main/SCREECHMASTER.mp3" preload="auto"></audio>
    <audio id="audio2" src="https://raw.githubusercontent.com/DjLess/MP3_repo/main/Somewhere%20Over%20The%20Rainbow%20-%20Polizzi%20Vs%20Richter%20(%20Israel%20IZ%20Techno%20Bootleg).mp3" preload="auto"></audio>

    <script>
        // Get references to audio elements
        const audio1 = document.getElementById('audio1');
        const audio2 = document.getElementById('audio2');

        // Get references to play/pause buttons
        const playPause1 = document.getElementById('play-pause-1');
        const playPause2 = document.getElementById('play-pause-2');

        // Get references to CUE buttons
        const cue1Button = document.getElementById('cue-1');
        const cue2Button = document.getElementById('cue-2');

        // Get references to the "Play All" debug button
        const debugPlayAllButton = document.getElementById('debug-play-all');

        // Get references to BPM sliders and their values
        const bpmSlider1 = document.getElementById('bpm-slider-1');
        const bpmValue1 = document.getElementById('bpm-value-1');
        const bpmSlider2 = document.getElementById('bpm-slider-2');
        const bpmValue2 = document.getElementById('bpm-value-2');

        // Get references to SYNC buttons
        const sync1 = document.getElementById('sync-1');
        const sync2 = document.getElementById('sync-2');

        // Get references to jog wheels
        const jogWheel1 = document.getElementById('jog-wheel-1');
        const jogWheel2 = document.getElementById('jog-wheel-2'); // Corrected to use 'jog-wheel-2' ID

        // Get references to the beat visualizer containers and their inner wrappers
        const beatVisualizer1 = document.getElementById('beat-visualizer-1');
        const beatVisualizer2 = document.getElementById('beat-visualizer-2');
        const beatBarsWrapper1 = document.getElementById('beat-bars-wrapper-1');
        const beatBarsWrapper2 = document.getElementById('beat-bars-wrapper-2');

        // Remapping for the old kick pulse logic (targeting the main visualizer div for the 'active' class)
        // IMPORTANT: These must be defined AFTER beatVisualizer1/2
        const kickPulse1 = beatVisualizer1;
        const kickPulse2 = beatVisualizer2;

        // Get reference to the synced kicks indicator
        const syncedKicksIndicator = document.getElementById('synced-kicks-indicator');

        // Get reference to the crossfader
        const crossfader = document.getElementById('crossfader');

        // NEW REFERENCES FOR ZOOM BUTTONS
        const zoomIn1 = document.getElementById('zoom-in-1');
        const zoomOut1 = document.getElementById('zoom-out-1');
        const zoomIn2 = document.getElementById('zoom-in-2');
        const zoomOut2 = document.getElementById('zoom-out-2');

        // Get references to the new SVG circle elements for the trace
        const jogTraceCircle1 = document.getElementById('jog-trace-circle-1');
        const jogTraceCircle2 = document.getElementById('jog-trace-circle-2');

        // NEW REFERENCES FOR VISUALIZATION FRAME AND TOGGLE
        const visualizationFrame = document.getElementById('visualization-frame');
        const toggleVisualization = document.getElementById('toggleVisualization');

        // NEW REFERENCES FOR SONG NAVIGATION BUTTONS
        const prev1Button = document.getElementById('prev-1');
        const next1Button = document.getElementById('next-1');
        const prev2Button = document.getElementById('prev-2');
        const next2Button = document.getElementById('next-2');

        // Variables to store kick intervals
        let kickInterval1 = null;
        let kickInterval2 = null;

        // Variables to store CUE points
        let cuePoint1 = 0; // Default to start of track
        let cuePoint2 = 0; // Default to start of track

        // Variables for beat visualization timeouts (for highlighting)
        let beatHighlightTimeouts1 = [];
        let beatHighlightTimeouts2 = [];

        // Variables for continuous animation control
        let animationFrameId1 = null; // for beat visualizer
        let animationFrameId2 = null; // for beat visualizer

        // Beat visualization configuration
        const SUB_BEATS_PER_MAIN_BEAT = 4; // Each main beat is divided into 4 sub-beats (e.g., 16th notes)

        // Zoom levels for beat visualization (number of main beats displayed)
        const ZOOM_LEVELS = [4, 8, 16, 32];
        let currentNumMainBeatsDisplayed1 = 8; // Initial display for track 1
        let currentNumMainMainBeatsDisplayed2 = 8; // Initial display for track 2

        // Constant for the total number of sub-beats to generate for continuous scrolling
        const TOTAL_GENERATED_SUB_BEATS = 64 * SUB_BEATS_PER_MAIN_BEAT; // Generate enough for 64 main beats (256 sub-beats)

        // Define minimum visual properties for bars and gaps
        const MIN_BAR_WIDTH_VISUAL = 1;
        const MIN_GAP_VISUAL = 0.5;

        // Reference BPM for visual density scaling
        const REFERENCE_BPM_FOR_VISUAL_DENSITY = 120; // Example reference BPM

        // Window of time in milliseconds during which a kick is considered "active"
        const KICK_ACTIVE_WINDOW_MS = 400;
        const BPM_TOLERANCE = 0.5;
        const VISUALIZATION_DURATION_MS = 200; // Duration in milliseconds that the visual kick pulse is active

        // Initial base BPMs for each track (made 'let' for dynamic updating)
        let initialBaseBPM1 = 145; // Default/fallback
        let initialBaseBPM2 = 130; // Default/fallback

        // Define the BPM range for sliders (+- 16 BPM)
        const BPM_RANGE = 16;

        // Song lists and current song index for each deck
        let allSongs1 = [
            { url: "https://raw.githubusercontent.com/DjLess/MP3_repo/main/SCREECHMASTER.mp3", title: "SCREECHMASTER", bpm: 145 },
            // Add more songs here for deck 1 if needed
        ];
        let currentSongIndex1 = 0;

        let allSongs2 = [
            { url: "https://raw.githubusercontent.com/DjLess/MP3_repo/main/Somewhere%20Over%20The%20Rainbow%20-%20Polizzi%20Vs%20Richter%20(%20Israel%20IZ%20Techno%20Bootleg).mp3", title: "Somewhere Over The Rainbow", bpm: 130 },
            // Add more songs here for deck 2 if needed
        ];
        let currentSongIndex2 = 0;

        /**
         * Loads a new song into the specified audio element and updates related UI.
         * @param {HTMLAudioElement} audio - The audio element (audio1 or audio2).
         * @param {Object} song - The song object { url, title, bpm }.
         * @param {HTMLElement} bpmValueElement - The element displaying the BPM value.
         * @param {HTMLInputElement} bpmSliderElement - The BPM slider element.
         * @param {number} deckNumber - 1 for deck 1, 2 for deck 2.
         */
        function loadSong(audio, song, bpmValueElement, bpmSliderElement, deckNumber) {
            audio.src = song.url;
            audio.load(); // Load the new audio
            
            // Update BPM display and slider
            if (song.bpm) {
                bpmValueElement.textContent = song.bpm.toFixed(1);
                setupBPMSlider(bpmSliderElement, song.bpm);
                if (deckNumber === 1) initialBaseBPM1 = song.bpm;
                else if (deckNumber === 2) initialBaseBPM2 = song.bpm;
            } else {
                bpmValueElement.textContent = 'N/A';
                setupBPMSlider(bpmSliderElement, REFERENCE_BPM_FOR_VISUAL_DENSITY); // Fallback BPM
                if (deckNumber === 1) initialBaseBPM1 = REFERENCE_BPM_FOR_VISUAL_DENSITY;
                else if (deckNumber === 2) initialBaseBPM2 = REFERENCE_BPM_FOR_VISUAL_DENSITY;
            }

            // If audio was playing, restart it (optional, based on desired behavior)
            if (!audio.paused) {
                audio.play().catch(e => console.error("Error playing audio after source change:", e));
            }

            // Restart beat animation interval with new BPM
            if (deckNumber === 1) {
                startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', parseFloat(bpmValue1.textContent), (a) => updateBeatVisualizer(a, bpmValue1, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1));
            } else if (deckNumber === 2) {
                startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', parseFloat(bpmValue2.textContent), (a) => updateBeatVisualizer(a, bpmValue2, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2));
            }
        }

        /**
         * Changes the song for a given deck (next or previous).
         * @param {number} deckNumber - 1 for deck 1, 2 for deck 2.
         * @param {string} direction - 'next' or 'prev'.
         */
        function changeSong(deckNumber, direction) {
            let songs, currentIndex;
            let audio, bpmValue, bpmSlider;

            if (deckNumber === 1) {
                songs = allSongs1;
                currentIndex = currentSongIndex1;
                audio = audio1;
                bpmValue = bpmValue1;
                bpmSlider = bpmSlider1;
            } else { // deckNumber === 2
                songs = allSongs2;
                currentIndex = currentSongIndex2;
                audio = audio2;
                bpmValue = bpmValue2;
                bpmSlider = bpmSlider2;
            }

            if (!songs || songs.length === 0) {
                console.warn(`No songs available for Deck ${deckNumber}.`);
                return;
            }

            if (direction === 'next') {
                currentIndex = (currentIndex + 1) % songs.length;
            } else if (direction === 'prev') {
                currentIndex = (currentIndex - 1 + songs.length) % songs.length;
            }

            // Update the current song index for the respective deck
            if (deckNumber === 1) currentSongIndex1 = currentIndex;
            else if (deckNumber === 2) currentSongIndex2 = currentIndex;

            const newSong = songs[currentIndex];
            loadSong(audio, newSong, bpmValue, bpmSlider, deckNumber);
            console.log(`Deck ${deckNumber} changed to: ${newSong.title} (BPM: ${newSong.bpm})`);
        }


        /**
         * Sets up the min/max range and initial value for a BPM slider.
         * @param {HTMLInputElement} slider - The BPM slider element.
         * @param {number} initialBPM - The initial BPM for the track.
         */
        function setupBPMSlider(slider, initialBPM) {
            // Invert min/max so that the highest value is visually at the top
            slider.min = (initialBPM - BPM_RANGE).toFixed(1);
            slider.max = (initialBPM + BPM_RANGE).toFixed(1);
            slider.value = initialBPM.toFixed(1); // Initial value is the base BPM
            slider.step = 0.1;
        }

        // Initialize BPM sliders with correct range
        setupBPMSlider(bpmSlider1, initialBaseBPM1);
        setupBPMSlider(bpmSlider2, initialBaseBPM2);

        /**
         * Activates the visual kick pulse for a specific duration.
         * @param {HTMLElement} element - The visual pulse element.
         */
        function activarVisualizacionKick(element) {
            element.classList.add('active');
            setTimeout(() => {
                element.classList.remove('active');
            }, VISUALIZATION_DURATION_MS);
        }

        /**
         * Starts the kick animation based on an interval.
         * @param {HTMLAudioElement} audio - The audio element.
         * @param {HTMLElement} pulseElement - The visual pulse element.
         * @param {string} intervalVariableName - Name of the global variable holding the interval ID (e.g., 'kickInterval1').
         * @param {number} bpm - Current BPM of the track.
         * @param {Function} [onBeatCallback] - Optional callback function to execute on each beat.
         */
        function startKickAnimationInterval(audio, pulseElement, intervalVariableName, bpm, onBeatCallback = null) {
            // Clear any existing interval for this track
            if (window[intervalVariableName]) {
                clearInterval(window[intervalVariableName]);
            }

            const msPerBeat = (60 / bpm) * 1000;

            // Start the interval
            window[intervalVariableName] = setInterval(() => {
                // Only activate the kick if audio is playing
                if (!audio.paused) {
                    activarVisualizacionKick(pulseElement);
                    if (onBeatCallback) {
                        onBeatCallback(audio); // Execute the callback on each beat, passing the audio element
                    }
                }
            }, msPerBeat);
        }

        /**
         * Continuously checks if kicks of both tracks are sounding simultaneously
         * (based on whether the visual element is active) and if BPMs are similar.
         */
        function checkSyncedKicks() {
            // Check if both visual kick elements are active
            const isKick1VisuallyActive = kickPulse1.classList.contains('active');
            const isKick2VisuallyActive = kickPulse2.classList.contains('active');

            // Get current BPMs (values displayed on the interface)
            const currentBPM1 = parseFloat(bpmValue1.textContent);
            const currentBPM2 = parseFloat(bpmValue2.textContent);

            // Check if BPMs are similar within the defined tolerance
            const areBPMsSimilar = Math.abs(currentBPM1 - currentBPM2) <= BPM_TOLERANCE;

            // Activate/deactivate sync indicator
            // Only activates if both kicks are visually active, BPMs are similar,
            // and both audios are playing.
            if (isKick1VisuallyActive && isKick2VisuallyActive && areBPMsSimilar && !audio1.paused && !audio2.paused) {
                syncedKicksIndicator.classList.add('active');
            } else {
                syncedKicksIndicator.classList.remove('active');
            }

            // Recursively call for a continuous loop in the next animation frame
            requestAnimationFrame(checkSyncedKicks);
        }

        /**
         * Clears all pending timeouts for beat highlighting for a given track.
         * @param {Array<number>} timeoutsArray - The array of timeout IDs.
         */
        function clearBeatHighlightTimeouts(timeoutsArray) {
            timeoutsArray.forEach(timeoutId => clearTimeout(timeoutId));
            timeoutsArray.length = 0; // Clear the array
        }

        /**
         * Generates and appends beat bars to the specified wrapper.
         * @param {HTMLElement} wrapper - The beat bars wrapper element.
         * @param {number} numMainBeats - The number of main beats to generate.
         * @param {number} subBeatsPerMainBeat - The number of sub-beats per main beat.
         * @param {number} wrapperWidth - The width of the beat visualizer container.
         */
        function generateBeatBars(wrapper, numMainBeats, subBeatsPerMainBeat, wrapperWidth) {
            wrapper.innerHTML = ''; // Clear existing bars

            const totalSubBeats = TOTAL_GENERATED_SUB_BEATS; // Generate a fixed large number of bars

            // Calculate optimal bar width and gap based on the wrapper width and number of beats to display
            const effectiveWidth = wrapperWidth - (MIN_GAP_VISUAL * (totalSubBeats - 1));
            let barWidth = Math.max(MIN_BAR_WIDTH_VISUAL, effectiveWidth / totalSubBeats);
            let gap = MIN_GAP_VISUAL;

            // Adjust barWidth if it becomes too large, potentially reducing gap if needed, or capping barWidth
            if (barWidth > (wrapperWidth / (totalSubBeats / 2))) { // Heuristic to prevent excessively wide bars
                barWidth = (wrapperWidth / (totalSubBeats / 2));
                gap = (wrapperWidth - (barWidth * totalSubBeats)) / (totalSubBeats - 1);
            }


            for (let i = 0; i < totalSubBeats; i++) {
                const beatBar = document.createElement('div');
                beatBar.classList.add('beat-bar');

                // Determine beat type
                if (i % subBeatsPerMainBeat === 0) {
                    beatBar.classList.add('beat-type-kick'); // Main beat (kick)
                } else if (i % (subBeatsPerMainBeat / 2) === 0) {
                    beatBar.classList.add('beat-type-2'); // Half-beat
                } else {
                    beatBar.classList.add('beat-type-4'); // Quarter-beat
                }

                beatBar.style.width = `${barWidth}px`;
                beatBar.style.marginRight = `${gap}px`; // Apply gap as right margin
                wrapper.appendChild(beatBar);
            }
        }

        /**
         * Updates the visual position and highlighting of beat bars.
         * @param {HTMLAudioElement} audio - The audio element.
         * @param {HTMLElement} bpmValueElement - The element displaying the BPM value.
         * @param {HTMLElement} beatBarsWrapper - The wrapper containing the beat bars.
         * @param {Array<number>} beatHighlightTimeouts - Array to store timeout IDs for beat highlighting.
         * @param {string} animationFrameIdVarName - The name of the global variable holding the requestAnimationFrame ID.
         * @param {number} numMainBeatsDisplayed - The number of main beats currently displayed in the visualizer.
         */
        function animateBeatBars(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, numMainBeatsDisplayed) {
            const currentBPM = parseFloat(bpmValueElement.textContent);
            if (isNaN(currentBPM) || currentBPM <= 0) {
                window[animationFrameIdVarName] = requestAnimationFrame((ts) => animateBeatBars(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, numMainBeatsDisplayed));
                return;
            }

            const msPerSubBeat = (60 / currentBPM / SUB_BEATS_PER_MAIN_BEAT) * 1000;
            const progress = audio.currentTime * 1000; // current time in milliseconds

            // Calculate the total width of all generated bars, including gaps
            const totalBars = TOTAL_GENERATED_SUB_BEATS;
            const barWidth = parseFloat(beatBarsWrapper.children[0]?.style.width || '0');
            const gap = parseFloat(beatBarsWrapper.children[0]?.style.marginRight || '0');
            const totalContentWidth = (barWidth + gap) * totalBars;

            // Calculate how many sub-beats are visible in the current view
            const beatVisualizerContainer = beatBarsWrapper.parentNode;
            const visibleWidth = beatVisualizerContainer ? beatVisualizerContainer.offsetWidth : 0;
            const visibleSubBeats = (numMainBeatsDisplayed * SUB_BEATS_PER_MAIN_BEAT);

            // Calculate the pixel width represented by one sub-beat at the current zoom level
            const pxPerSubBeat = visibleWidth / visibleSubBeats;

            // Calculate the scroll position based on current audio time
            const scrollOffsetPx = (progress / msPerSubBeat) * pxPerSubBeat;

            // Center the "active beat" under the red line indicator
            const centerOffset = (visibleWidth / 2) - (pxPerSubBeat / 2); // Center of the visualizer minus half a sub-beat width

            // Apply the transform to the wrapper to create the scrolling effect
            beatBarsWrapper.style.transform = `translateX(${-scrollOffsetPx + centerOffset}px)`;


            // Highlighting logic (remains similar, but based on calculated current sub-beat index)
            const currentSubBeatIndex = Math.floor(progress / msPerSubBeat);

            // Clear previous highlights
            clearBeatHighlightTimeouts(beatHighlightTimeouts);

            // Highlight the current beat and next beat
            const bars = Array.from(beatBarsWrapper.children);

            // Highlight the current beat
            if (bars[currentSubBeatIndex]) {
                bars[currentSubBeatIndex].classList.add('active-beat');
                beatHighlightTimeouts.push(setTimeout(() => {
                    bars[currentSubBeatIndex]?.classList.remove('active-beat');
                }, msPerSubBeat / 2)); // Remove highlight after half a sub-beat
            }

            // Highlight the next beat (anticipatory)
            if (bars[currentSubBeatIndex + 1]) {
                bars[currentSubBeatIndex + 1].classList.add('next-beat');
                beatHighlightTimeouts.push(setTimeout(() => {
                    bars[currentSubBeatIndex + 1]?.classList.remove('next-beat');
                }, msPerSubBeat / 2));
            }

            // Request next frame if audio is playing
            if (!audio.paused) {
                window[animationFrameIdVarName] = requestAnimationFrame((ts) => animateBeatBars(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, numMainBeatsDisplayed));
            }
        }


        /**
         * Updates the beat visualizer for a given track.
         * This function handles both generating the bars and animating them.
         * @param {HTMLAudioElement} audio - The audio element.
         * @param {HTMLElement} bpmValueElement - The element displaying the BPM.
         * @param {HTMLElement} beatBarsWrapper - The wrapper for beat bars.
         * @param {Array<number>} beatHighlightTimeouts - Array for highlight timeouts.
         * @param {string} animationFrameIdVarName - Variable name for animation frame ID.
         * @param {number} numMainBeatsDisplayed - Number of main beats to display.
         * @param {boolean} [regenerate=false] - If true, regenerate all beat bars.
         */
        function updateBeatVisualizer(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, numMainBeatsDisplayed, regenerate = false) {
            if (regenerate) {
                // Cancel any existing animation frame for this visualizer
                if (window[animationFrameIdVarName]) {
                    cancelAnimationFrame(window[animationFrameIdVarName]);
                    window[animationFrameIdVarName] = null;
                }
                const visualizerContainer = beatBarsWrapper.parentNode;
                const wrapperWidth = visualizerContainer ? visualizerContainer.offsetWidth : 0;
                generateBeatBars(beatBarsWrapper, numMainBeatsDisplayed, SUB_BEATS_PER_MAIN_BEAT, wrapperWidth);
            }

            // Always call animateBeatBars, which will handle its own requestAnimationFrame loop
            animateBeatBars(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, numMainBeatsDisplayed);
        }

        // Initialize beat visualizers once the page is loaded and container dimensions are available
        window.addEventListener('DOMContentLoaded', () => {
            updateBeatVisualizer(audio1, bpmValue1, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1, true);
            updateBeatVisualizer(audio2, bpmValue2, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2, true);
        });

        // Start the continuous check for synced kicks
        checkSyncedKicks();

        // Event Listeners for Play/Pause buttons
        playPause1.addEventListener('click', () => {
            if (audio1.paused) {
                audio1.play().then(() => {
                    playPause1.textContent = '⏸️ PAUSE A';
                    startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', parseFloat(bpmValue1.textContent), (a) => updateBeatVisualizer(a, bpmValue1, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1));
                }).catch(e => console.error("Error playing audio1:", e));
            } else {
                audio1.pause();
                playPause1.textContent = '▶️ PLAY A';
                clearInterval(kickInterval1); // Stop the kick animation interval
                cancelAnimationFrame(animationFrameId1); // Stop beat bar animation
                animationFrameId1 = null;
            }
        });

        playPause2.addEventListener('click', () => {
            if (audio2.paused) {
                audio2.play().then(() => {
                    playPause2.textContent = '⏸️ PAUSE B';
                    startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', parseFloat(bpmValue2.textContent), (a) => updateBeatVisualizer(a, bpmValue2, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2));
                }).catch(e => console.error("Error playing audio2:", e));
            } else {
                audio2.pause();
                playPause2.textContent = '▶️ PLAY B';
                clearInterval(kickInterval2); // Stop the kick animation interval
                cancelAnimationFrame(animationFrameId2); // Stop beat bar animation
                animationFrameId2 = null;
            }
        });

        // Event Listeners for CUE buttons
        cue1Button.addEventListener('click', () => {
            if (audio1.paused) {
                // If paused, set cue point
                cuePoint1 = audio1.currentTime;
                console.log(`CUE point for Audio 1 set at: ${cuePoint1.toFixed(2)}s`);
            } else {
                // If playing, jump to cue point
                audio1.currentTime = cuePoint1;
            }
        });

        cue2Button.addEventListener('click', () => {
            if (audio2.paused) {
                // If paused, set cue point
                cuePoint2 = audio2.currentTime;
                console.log(`CUE point for Audio 2 set at: ${cuePoint2.toFixed(2)}s`);
            } else {
                // If playing, jump to cue point
                audio2.currentTime = cuePoint2;
            }
        });

        // Event Listener for Debug Play All button
        debugPlayAllButton.addEventListener('click', () => {
            console.log("Debug Play All clicked!");

            // Play audio1
            if (audio1.paused) {
                audio1.play().then(() => {
                    playPause1.textContent = '⏸️ PAUSE A';
                    startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', parseFloat(bpmValue1.textContent), (a) => updateBeatVisualizer(a, bpmValue1, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1));
                }).catch(e => console.error("Error playing audio1 from Play All:", e));
            }

            // Play audio2
            if (audio2.paused) {
                audio2.play().then(() => {
                    playPause2.textContent = '⏸️ PAUSE B';
                    startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', parseFloat(bpmValue2.textContent), (a) => updateBeatVisualizer(a, bpmValue2, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2));
                }).catch(e => console.error("Error playing audio2 from Play All:", e));
            }
        });

        // Event Listeners for BPM Sliders
        bpmSlider1.addEventListener('input', (event) => {
            const newBPM = parseFloat(event.target.value);
            bpmValue1.textContent = newBPM.toFixed(1);
            // Re-start the kick animation interval with the new BPM
            startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', newBPM, (a) => updateBeatVisualizer(a, bpmValue1, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1));
        });

        bpmSlider2.addEventListener('input', (event) => {
            const newBPM = parseFloat(event.target.value);
            bpmValue2.textContent = newBPM.toFixed(1);
            // Re-start the kick animation interval with the new BPM
            startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', newBPM, (a) => updateBeatVisualizer(a, bpmValue2, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2));
        });

        // Event Listeners for SYNC buttons
        sync1.addEventListener('click', () => {
            // Sync audio1's BPM to audio2's BPM
            const targetBPM = parseFloat(bpmValue2.textContent);
            bpmSlider1.value = targetBPM.toFixed(1);
            bpmValue1.textContent = targetBPM.toFixed(1);
            startKickAnimationInterval(audio1, kickPulse1, 'kickInterval1', targetBPM, (a) => updateBeatVisualizer(a, bpmValue1, beatBarsWrapper1, beatHighlightTimeouts1, 'animationFrameId1', currentNumMainBeatsDisplayed1));
            console.log(`Audio 1 synced to Audio 2's BPM: ${targetBPM}`);
        });

        sync2.addEventListener('click', () => {
            // Sync audio2's BPM to audio1's BPM
            const targetBPM = parseFloat(bpmValue1.textContent);
            bpmSlider2.value = targetBPM.toFixed(1);
            bpmValue2.textContent = targetBPM.toFixed(1);
            startKickAnimationInterval(audio2, kickPulse2, 'kickInterval2', targetBPM, (a) => updateBeatVisualizer(a, bpmValue2, beatBarsWrapper2, beatHighlightTimeouts2, 'animationFrameId2', currentNumMainMainBeatsDisplayed2));
            console.log(`Audio 2 synced to Audio 1's BPM: ${targetBPM}`);
        });

        // Crossfader logic
        crossfader.addEventListener('input', (event) => {
            const value = parseFloat(event.target.value); // Value between 0 and 1
            audio1.volume = 1 - value; // When slider is at 0, audio1 is full volume
            audio2.volume = value;     // When slider is at 1, audio2 is full volume
        });

        // Initialize volumes
        audio1.volume = 0.5;
        audio2.volume = 0.5;

        // Jog Wheel Logic (simplified for rotation, not full scratching)
        // Note: Real jog wheel logic involves more complex audio manipulation (pitch, tempo, scratching)
        // This simulates a basic rotational input.

        let isDragging1 = false;
        let lastAngle1 = 0;

        jogWheel1.addEventListener('mousedown', (e) => {
            isDragging1 = true;
            const rect = jogWheel1.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            lastAngle1 = Math.atan2(e.clientY - centerY, e.clientX - centerX);
            jogWheel1.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging1) return;

            const rect = jogWheel1.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);

            let deltaAngle = currentAngle - lastAngle1;

            // Handle angle wrapping (e.g., crossing from -PI to PI)
            if (deltaAngle > Math.PI) {
                deltaAngle -= 2 * Math.PI;
            } else if (deltaAngle < -Math.PI) {
                deltaAngle += 2 * Math.PI;
            }

            // Apply rotation to the jog wheel visually
            const currentTransform = getComputedStyle(jogWheel1).transform;
            let currentRotation = 0;
            const match = currentTransform.match(/rotate\(([^)]+)deg\)/);
            if (match && match[1]) {
                currentRotation = parseFloat(match[1]);
            }
            const newRotation = currentRotation + (deltaAngle * (180 / Math.PI)); // Convert radians to degrees
            jogWheel1.style.transform = `rotate(${newRotation}deg)`;

            // Update audio playback rate based on jog wheel movement
            // This is a simplified pitch bend effect
            const pitchBendFactor = deltaAngle * 0.5; // Adjust sensitivity as needed
            audio1.playbackRate = 1 + pitchBendFactor;
            // Clamp playbackRate to avoid extreme values
            audio1.playbackRate = Math.max(0.5, Math.min(2.0, audio1.playbackRate));


            // Update SVG trace rotation based on jog wheel rotation
            jogTraceCircle1.style.transform = `rotate(${newRotation}deg)`;


            lastAngle1 = currentAngle;
        });

        document.addEventListener('mouseup', () => {
            if (isDragging1) {
                isDragging1 = false;
                jogWheel1.style.cursor = 'grab';
                // Reset playback rate smoothly after releasing the jog wheel
                audio1.playbackRate = 1;
            }
        });


        let isDragging2 = false;
        let lastAngle2 = 0;

        jogWheel2.addEventListener('mousedown', (e) => {
            isDragging2 = true;
            const rect = jogWheel2.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            lastAngle2 = Math.atan2(e.clientY - centerY, e.clientX - centerX);
            jogWheel2.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging2) return;

            const rect = jogWheel2.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);

            let deltaAngle = currentAngle - lastAngle2;

            if (deltaAngle > Math.PI) {
                deltaAngle -= 2 * Math.PI;
            } else if (deltaAngle < -Math.PI) {
                deltaAngle += 2 * Math.PI;
            }

            const currentTransform = getComputedStyle(jogWheel2).transform;
            let currentRotation = 0;
            const match = currentTransform.match(/rotate\(([^)]+)deg\)/);
            if (match && match[1]) {
                currentRotation = parseFloat(match[1]);
            }
            const newRotation = currentRotation + (deltaAngle * (180 / Math.PI));
            jogWheel2.style.transform = `rotate(${newRotation}deg)`;

            const pitchBendFactor = deltaAngle * 0.5;
            audio2.playbackRate = 1 + pitchBendFactor;
            audio2.playbackRate = Math.max(0.5, Math.min(2.0, audio2.playbackRate));

            jogTraceCircle2.style.transform = `rotate(${newRotation}deg)`;

            lastAngle2 = currentAngle;
        });

        document.addEventListener('mouseup', () => {
            if (isDragging2) {
                isDragging2 = false;
                jogWheel2.style.cursor = 'grab';
                audio2.playbackRate = 1;
            }
        });

        // Progress Bar Logic for Waveform
        function updateProgressBar(audio, progressBarElement) {
            if (audio.duration) {
                const progress = (audio.currentTime / audio.duration) * 100;
                progressBarElement.style.width = `${progress}%`;
            }
            requestAnimationFrame(() => updateProgressBar(audio, progressBarElement));
        }

        // Add waveform progress bars (assuming you have elements for them)
        // For example, if you add:
        // <div id="waveform-progress-1" class="waveform-progress"></div> inside your waveform div for audio1
        // <div id="waveform-progress-2" class="waveform-progress"></div> inside your waveform div for audio2
        // Then you'd get their references and call updateProgressBar
        const waveformProgress1 = document.getElementById('waveform-progress-1'); // Make sure these exist in HTML
        const waveformProgress2 = document.getElementById('waveform-progress-2'); // Make sure these exist in HTML

        // Call updateProgressBar for each audio element
        if (waveformProgress1) updateProgressBar(audio1, waveformProgress1);
        if (waveformProgress2) updateProgressBar(audio2, waveformProgress2);


        // Zoom functionality for Beat Visualizers
        function setupZoomButtons(zoomInBtn, zoomOutBtn, beatBarsWrapper, audio, bpmValueElement, beatHighlightTimeouts, animationFrameIdVarName, numMainBeatsDisplayedVarName, deckNumber) {
            zoomInBtn.addEventListener('click', () => {
                let currentZoomIndex = ZOOM_LEVELS.indexOf(window[numMainBeatsDisplayedVarName]);
                if (currentZoomIndex > 0) {
                    window[numMainBeatsDisplayedVarName] = ZOOM_LEVELS[currentZoomIndex - 1];
                    updateBeatVisualizer(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, window[numMainBeatsDisplayedVarName], true);
                    console.log(`Deck ${deckNumber} Zoom In: ${window[numMainBeatsDisplayedVarName]} beats displayed.`);
                }
            });

            zoomOutBtn.addEventListener('click', () => {
                let currentZoomIndex = ZOOM_LEVELS.indexOf(window[numMainBeatsDisplayedVarName]);
                if (currentZoomIndex < ZOOM_LEVELS.length - 1) {
                    window[numMainBeatsDisplayedVarName] = ZOOM_LEVELS[currentZoomIndex + 1];
                    updateBeatVisualizer(audio, bpmValueElement, beatBarsWrapper, beatHighlightTimeouts, animationFrameIdVarName, window[numMainBeatsDisplayedVarName], true);
                    console.log(`Deck ${deckNumber} Zoom Out: ${window[numMainBeatsDisplayedVarName]} beats displayed.`);
                }
            });
        }

        setupZoomButtons(zoomIn1, zoomOut1, beatBarsWrapper1, audio1, bpmValue1, beatHighlightTimeouts1, 'animationFrameId1', 'currentNumMainBeatsDisplayed1', 1);
        setupZoomButtons(zoomIn2, zoomOut2, beatBarsWrapper2, audio2, bpmValue2, beatHighlightTimeouts2, 'animationFrameId2', 'currentNumMainMainBeatsDisplayed2', 2);


        // Minigame/Visualization Frame Logic
        const minigameStartButton = document.getElementById('minigame-start-button');
        const minigameMessageBox = document.getElementById('minigameMessageBox');
        let gameRunning = false;
        let gameScore = 0;
        const gameScoreElement = document.getElementById('game-score');

        const canvas = document.getElementById('platformGameCanvas');
        const ctx = canvas.getContext('2d');

        const ballRadius = 10;
        let ballX, ballY, ballDy; // Position and vertical velocity
        const gravity = 0.3;
        const jumpStrength = -6;

        let platforms = [];
        const platformWidth = 60;
        const platformHeight = 10;
        const platformSpacing = 80;
        const numPlatforms = 5;

        // Ensure canvas matches parent size
        function resizeCanvas() {
            const gameArea = document.getElementById('platform-game-area');
            canvas.width = gameArea.offsetWidth;
            canvas.height = gameArea.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial resize

        function resetGame() {
            gameScore = 0;
            gameScoreElement.textContent = `Score: ${gameScore}`;
            ballX = canvas.width / 2;
            ballY = canvas.height - ballRadius - platformHeight; // Start above the initial platform
            ballDy = 0;
            platforms = [];
            createInitialPlatforms();
            minigameMessageBox.style.display = 'none';
        }

        function createInitialPlatforms() {
            // First platform at the bottom
            platforms.push({
                x: canvas.width / 2 - platformWidth / 2,
                y: canvas.height - platformHeight,
                width: platformWidth,
                height: platformHeight,
                isBase: true // Indicate this is the base platform
            });

            // Generate other platforms
            for (let i = 1; i < numPlatforms; i++) {
                createRandomPlatform();
            }
        }

        function createRandomPlatform() {
            const lastPlatform = platforms[platforms.length - 1];
            const newY = lastPlatform.y - platformSpacing;
            const newX = Math.random() * (canvas.width - platformWidth);
            platforms.push({
                x: newX,
                y: newY,
                width: platformWidth,
                height: platformHeight
            });
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#FFD700'; // Gold
            ctx.shadowColor = 'rgba(246, 224, 94, 0.7)';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowColor = 'transparent'; // Reset shadow
        }

        function drawPlatforms() {
            ctx.fillStyle = '#4682b4'; // Steel Blue
            platforms.forEach(p => {
                ctx.fillRect(p.x, p.y, p.width, p.height);
            });
        }

        function updateGame() {
            if (!gameRunning) return;

            // Apply gravity
            ballDy += gravity;
            ballY += ballDy;

            // Check for collision with platforms
            platforms.forEach(p => {
                if (
                    ballY + ballRadius > p.y &&
                    ballY - ballRadius < p.y + p.height &&
                    ballX + ballRadius > p.x &&
                    ballX - ballRadius < p.x + p.width &&
                    ballDy > 0 // Only land if falling
                ) {
                    ballY = p.y - ballRadius; // Snap to top of platform
                    ballDy = jumpStrength; // Simulate a bounce/jump
                    gameScore++; // Increase score on successful jump
                    gameScoreElement.textContent = `Score: ${gameScore}`;
                }
            });

            // Move platforms down as player moves up
            if (ballY < canvas.height / 2 && ballDy < 0) { // If ball goes above half-screen while jumping
                const scrollAmount = -ballDy; // Scroll platforms down by ball's upward speed
                platforms.forEach(p => p.y += scrollAmount);
                ballY += scrollAmount; // Keep ball relatively in the middle

                // Remove off-screen platforms and add new ones
                platforms = platforms.filter(p => p.y < canvas.height);
                while (platforms.length < numPlatforms) {
                    createRandomPlatform();
                }
            }


            // Game over condition (fall off screen)
            if (ballY > canvas.height + ballRadius) {
                endGame(`Game Over! Final Score: ${gameScore}`);
                return;
            }

            // Game over condition (hit the top of the screen without a platform)
            if (ballY < 0 && ballDy < 0) {
                 endGame(`Game Over! Final Score: ${gameScore}`);
                 return;
            }

            // Keep ball within horizontal bounds
            if (ballX - ballRadius < 0) {
                ballX = ballRadius;
            } else if (ballX + ballRadius > canvas.width) {
                ballX = canvas.width - ballRadius;
            }

            renderGame();
            requestAnimationFrame(updateGame);
        }

        function renderGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPlatforms();
            drawBall();
        }

        function startGame() {
            if (gameRunning) return; // Prevent multiple starts
            gameRunning = true;
            resetGame();
            updateGame(); // Start the game loop
            minigameStartButton.textContent = "Restart Game"; // Change button text
        }

        function endGame(message) {
            gameRunning = false;
            minigameMessageBox.textContent = message;
            minigameMessageBox.style.display = 'block';
            minigameStartButton.textContent = "Start Game";
        }


        minigameStartButton.addEventListener('click', startGame);

        // Control ball horizontally with jog wheels (simplified example)
        // This is a basic example; you might want more sophisticated control
        jogWheel1.addEventListener('mousemove', (e) => {
            if (isDragging1 && gameRunning) {
                const rect = jogWheel1.getBoundingClientRect();
                const deltaX = e.movementX; // Mouse movement in X
                ballX += deltaX * 0.5; // Adjust sensitivity
            }
        });

        jogWheel2.addEventListener('mousemove', (e) => {
            if (isDragging2 && gameRunning) {
                const rect = jogWheel2.getBoundingClientRect();
                const deltaX = e.movementX; // Mouse movement in X
                ballX += deltaX * 0.5; // Adjust sensitivity
            }
        });


        // Toggle Visualization Frame
        toggleVisualization.addEventListener('change', () => {
            if (toggleVisualization.checked) {
                visualizationFrame.classList.add('active');
                // If game is not running, start it by default when visualization is shown
                if (!gameRunning) {
                    startGame();
                }
            } else {
                visualizationFrame.classList.remove('active');
                // Optional: Stop game when visualization is hidden
                if (gameRunning) {
                    endGame("Game Paused"); // Or simply stop without a message
                }
            }
        });

        // Event Listeners for the new song navigation buttons
        prev1Button.addEventListener('click', () => changeSong(1, 'prev'));
        next1Button.addEventListener('click', () => changeSong(1, 'next'));
        prev2Button.addEventListener('click', () => changeSong(2, 'prev'));
        next2Button.addEventListener('click', () => changeSong(2, 'next'));

        // Listen for messages from parent (e.g., if this HTML is embedded in an iframe)
        window.addEventListener("message", function(event) {
            const data = event.data;

            if (
                data &&
                data.type === "musicData" &&
                Array.isArray(data.payload) &&
                data.payload.length > 0
            ) {
                // Assuming payload contains a list of song pairs
                // For simplicity, we'll just take the first pair for now
                // and assign them to the respective decks.
                const pair = data.payload[0]; // Assuming [{audio1: {}, audio2: {}}]

                if (pair.audio1) {
                    allSongs1 = [pair.audio1]; // Replace with new song list
                    currentSongIndex1 = 0;
                    loadSong(audio1, allSongs1[currentSongIndex1], bpmValue1, bpmSlider1, 1);
                    console.log("✅ Received music data for Sapito Game (Deck 1):", allSongs1[currentSongIndex1].title);
                } else {
                    console.warn("⚠️ musicData payload[0].audio1 is missing or invalid.");
                }

                if (pair.audio2) {
                    allSongs2 = [pair.audio2]; // Replace with new song list
                    currentSongIndex2 = 0;
                    loadSong(audio2, allSongs2[currentSongIndex2], bpmValue2, bpmSlider2, 2);
                    console.log("✅ Received music data for Sapito Game (Deck 2):", allSongs2[currentSongIndex2].title);
                } else {
                    console.warn("⚠️ musicData payload[0].audio2 is missing or invalid.");
                }

            } else {
                console.warn("⚠️ Error en datos recibidos por postMessage:", data);
                console.warn("🔍 Estado interno - Validaciones:");
                console.warn("-> data.type:", data?.type);
                console.warn("-> payload:", data?.payload);
                console.warn("-> payload[0].audio1:", data?.payload?.[0]?.audio1);
                console.warn("-> payload[0].audio2:", data?.payload?.[0]?.audio2);
            }
        });
    </script>
</body>
</html>
